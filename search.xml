<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Harbor部署</title>
    <url>/2022/05/25/Harbor%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Harbor 概述</p>
<p>Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展， 从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及 审计日志等，足以满足基本企业需求。</p>
<p>官方：<a href="https://goharbor.io/">https://goharbor.io/</a></p>
<p>Github：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>Harbor 部署先决条件</p>
<p>服务器硬件配置：</p>
<p>最低要求：CPU2核/内存4G/硬盘40GB</p>
<p>推荐：CPU4核/内存8G/硬盘160GB</p>
<p>软件：</p>
<p>Docker CE 17.06版本+</p>
<p>Docker Compose 1.18版本+</p>
<p>Harbor安装有2种方式：</p>
<p>在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小</p>
<p>离线安装：安装包包含部署的相关镜像，因此安装包比较大</p>
<p>Harbor 部署HTTP</p>
<p>1、先安装Docker和Docker Compose</p>
<p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<p>2、部署Harbor HTTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar zxvf harbor-offline-installer-v2.0.0.tgz </span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: reg.azhe.com </span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>3、访问harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://reg.azhe.com/</span><br></pre></td></tr></table></figure>
<p><img src="/images/65FF30622A314D5391BD5ACBBEC52776clipboard.png" alt></p>
<p>Harbor 基本使用</p>
<p>1、配置http镜像仓库可信任（默认是https访问的，上面配置的是http，这里需要配置可信任)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置http镜像仓库可信任</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;reg.azhe.com&quot;</span>]&#125; </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看是否有harbor容器退出，重新停止再拉起</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>2.配置本地hosts文件解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>3.登录harbbor,打标签，上传，下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker tag mysql:5.7 reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker push reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p><img src="/images/158D447BE1A84A4C96A9CC38A8FF762Dclipboard.png" alt></p>
<p>Harbor 部署HTTPS</p>
<p>1、生成SSL证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ssl</span><br><span class="line"><span class="built_in">cd</span> ssl</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">ca-config.json  ca-key.pem  cfssl.sh               reg.azhe.com-key.pem</span><br><span class="line">ca.csr          ca.pem      reg.azhe.com.csr       reg.azhe.com.pem</span><br><span class="line">ca-csr.json     certs.sh    reg.azhe.com-csr.json</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://cfssl.sh">cfssl.sh</a> (证书生成工具）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://certs.sh">certs.sh</a>(证书生成脚本）</p>
<p>#注意里面的域名修改为自己的harbor域名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; reg.azhe.com-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;reg.azhe.com&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes reg.azhe.com-csr.json | cfssljson -bare reg.azhe.com </span><br></pre></td></tr></table></figure>
<p>2、Harbor启用HTTPS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi harbor.yml</span><br><span class="line">https:</span><br><span class="line">  port: 443</span><br><span class="line">   certificate: /root/ssl/reg.azhe.com.pem     <span class="comment">#指定你生成的数字证书</span></span><br><span class="line">   private_key: /root/ssl/reg.azhe.com-key.pem   <span class="comment">#指定key</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>3、重新配置并部署Harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prepare </span><br><span class="line">docker-compose down </span><br><span class="line">docker-compose up –d</span><br></pre></td></tr></table></figure>
<p>4、修改Docker启动文件添加“–insecure-registry <a href="http://reg.azhe.com">reg.azhe.com</a>”并配置hosts文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry reg.azhe.com</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>5、验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p>以上harbor部署https方式的第4步骤，如果配置完成后，在docker主机登录harbor报证书错误，那么可以通过以下方式解决或参考链接：</p>
<p>4.将数字证书复制到Docker主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp reg.azhe.com.pem root@192.168.0.13:~   <span class="comment">#拷贝到要登录harbor的docker客户端</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/docker/certs.d/reg.azhe.com</span><br><span class="line"><span class="built_in">cp</span> reg.azhe.com.pem /etc/docker/certs.d/reg.azhe.com/reg.azhe.com.crt</span><br></pre></td></tr></table></figure>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/chenglang0914/article/details/100833054">https://blog.csdn.net/chenglang0914/article/details/100833054</a></p>
<p>Harbor 主从复制</p>
<p><img src="/images/B77A284AA7994A2894263F4F287452E8clipboard.png" alt></p>
<p>主备模式</p>
<p>1.准备备机harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar -zxf harbor-offline-installer-v2.0.0.tgz</span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: 192.168.0.12</span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>2.在主harbor页面配置主从复制和规则</p>
<p><img src="/images/2A099C79ECDB4C83B3D5917E0BDA3BE6clipboard.png" alt></p>
<p><img src="/images/2726A20B44774F2EABFB8A0F45DDC380clipboard.png" alt></p>
<p>3.客户端docker主机上传镜像到主harbor并验证是否复制到从harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker tag centos:7 reg.azhe.com/library/centos:7</span><br><span class="line">docker push reg.azhe.com/library/centos:7</span><br></pre></td></tr></table></figure>
<p><img src="/images/F29DE1853ED34C21961D7A4A2EEB9CADclipboard.png" alt></p>
<p><img src="/images/FF5C2BF9C43248F4AE5521F5F200F61Cclipboard.png" alt></p>
<p><img src="/images/71319B66EA1E4E36A28CDFA7BE80681Eclipboard.png" alt></p>
<p>Harbor 运维维护</p>
<p><img src="/images/4CBC3EA772514E54B38302F5409C461Aclipboard.png" alt></p>
<p>容器数据持久化目录：/data</p>
<p>日志文件目录：/var/log/harbor</p>
<p>PG数据库做好定期备份，里面存放用户数据文件。</p>
<p>主从复制，主harbor挂掉，启用备harbor，需要把pg数据导入到备harbor。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA项目镜像构建：Tomcat</title>
    <url>/2022/05/23/JAVA%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>JAVA项目镜像构建：Tomcat</p>
<p>tomcat目录文件：1.apache-tomcat-8.5.43.tar.gz  2.Dockerfile   3.Dockerfile2  4.ROOT.war</p>
<p>Dockerfile（环境镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dockerfile2 (基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM tomcat:v1</span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/tomcat/webapps/*</span><br><span class="line">COPY ROOT.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> tomcat/</span><br><span class="line">docker build -t tomcat:v1 .</span><br><span class="line">docker build -t tomcat:v2 -f Dockerfile2 .</span><br><span class="line">docker run -d -p 8888:8080 --name tomcat tomcat:v2</span><br></pre></td></tr></table></figure>
<p>访问tomcat 8888端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.0.11:8888/</span><br></pre></td></tr></table></figure>
<p>JAVA微服务镜像构建：Jar</p>
<p>java目录文件:1.Dockerfile  2.hello.jar</p>
<p>Dockerfile(基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM java:8-jdk-alpine</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">ENV JAVA_OPTS=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> -Dfile.encoding=UTF8 -Duser.timezone=GMT+08&quot;</span></span><br><span class="line">RUN sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="line">    apk add -U tzdata &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">COPY hello.jar /</span><br><span class="line">EXPOSE 8888</span><br><span class="line">CMD [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar <span class="variable">$JAVA_OPTS</span> /hello.jar&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写Dockerfile最佳实践</p>
<p>减少镜像层：一次RUN指令形成新的一层，尽量Shell命令都写在一行，减少镜像层。</p>
<p>优化镜像大小：一次RUN形成新的一层，如果没有在同一层删除，无论文件是否最后删除， 都会带到下一层，所以要在每一层清理对应的残留数据，减小镜像大小。</p>
<p>减少网络传输时间：例如软件包、mvn仓库等</p>
<p>多阶段构建：代码编译、部署在一个Dockerfile完成，只会保留部署阶段产生数据。</p>
<p>选择最小的基础镜像：例如alpine</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes核心概念</title>
    <url>/2022/06/10/Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="有了Docker，为什么还用Kubernetes？">有了Docker，为什么还用Kubernetes？</h2>
<h4 id="为提高业务并发和高可用，会使用多台服务器，因此会面向这些问题：">为提高业务并发和高可用，会使用多台服务器，因此会面向这些问题：</h4>
<ul>
<li>
<p>多容器跨主机提供服务</p>
</li>
<li>
<p>多容器分布节点部署</p>
</li>
<li>
<p>多容器怎么升级</p>
</li>
<li>
<p>怎么高效管理这些容器</p>
</li>
</ul>
<p><img src="/images/28FBDEB7C0804F9C9A9E53A5C9DEC0C5clipboard.png" alt></p>
<h4 id="容器编排系统：">容器编排系统：</h4>
<ul>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>Swarm</p>
</li>
<li>
<p>Mesos Marathon</p>
</li>
</ul>
<p><img src="/images/B1FE2493A067433EBB99A47D55740E33clipboard.png" alt></p>
<h2 id="Kubernetes是什么">Kubernetes是什么</h2>
<ul>
<li>
<p>Kubernetes是Google在2014年开源的一个容器集群管理系统，Kubernetes简称K8s。</p>
</li>
<li>
<p>Kubernetes用于容器化应用程序的部署，扩展和管理，目标是让部署容器化应用简单高效</p>
</li>
</ul>
<p>官方网站：<a href="http://www.kubernetes.io/">http://www.kubernetes.io/</a></p>
<p>官方文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></p>
<h2 id="Kubernetes集群架构与组件">Kubernetes集群架构与组件</h2>
<p><img src="/images/2C6E9B5C538E4A97A18CC499EFCC98ADclipboard.png" alt></p>
<p><img src="/images/FF51CE19DAFF43B6AEB17650553CE68Aclipboard.png" alt></p>
<h3 id="Master组件">Master组件</h3>
<p>kube-apiserver</p>
<p>Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对			   象资源的增删改查和监听操作都交给 APIServer处理后再提交给Etcd存储。</p>
<p>kube-controller-manager</p>
<p>处理集群中常规后台任务，一个资源对应一个控制器，而 ControllerManager就是负责管理这些控制器的。</p>
<p>kube-scheduler</p>
<p>根据调度算法为新创建的Pod选择一个Node节点，可以任意部署, 可以部署在同一个节点上,也可以部署在不同的节点上。</p>
<p>etcd</p>
<p>分布式键值存储系统。用于保存集群状态数据，比如Pod、Service 等对象信息。</p>
<h3 id="Node组件">Node组件</h3>
<p>kubelet</p>
<p>kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周 期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态 等工作。kubelet将每个Pod转换成一组容器。</p>
<p>kube-proxy</p>
<p>在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。</p>
<p>docker或rocket</p>
<p>容器引擎，运行容器。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Service(对外暴露你的应用）</title>
    <url>/2022/06/17/Service(%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Service是什么与Service存在的意义">Service是什么与Service存在的意义</h2>
<p>Service引入主要是解决Pod的动态变化，提供统一访问入口：</p>
<ul>
<li>
<p>防止Pod失联，准备找到提供同一个服务的Pod（服务发现）</p>
</li>
<li>
<p>定义一组Pod的访问策略（负载均衡）</p>
</li>
</ul>
<p><img src="/images/46FCA6D1D1DE4CB1BF7404E3E644AB9Bclipboard.png" alt></p>
<h3 id="Pod与Service的关系">Pod与Service的关系</h3>
<ul>
<li>
<p>Service通过标签关联一组Pod</p>
</li>
<li>
<p>Service使用iptables或者ipvs为一组Pod提供负载均衡能力</p>
</li>
</ul>
<p><img src="/images/D28365050B2C4212BD3B918D4E543123clipboard.png" alt></p>
<h3 id="Service定义与创建">Service定义与创建</h3>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建service： </span></span><br><span class="line">kubectl apply -f service.yaml </span><br><span class="line"><span class="comment">#查看service： </span></span><br><span class="line">kubectl get service</span><br><span class="line"><span class="comment">#查看service关联一组pod的IP</span></span><br><span class="line">kubectl get endpoints</span><br></pre></td></tr></table></figure>
<h2 id="Service三种类型">Service三种类型</h2>
<ul>
<li>
<p>ClusterIP：集群内部使用</p>
</li>
<li>
<p>NodePort：对外暴露应用（集群外）</p>
</li>
<li>
<p>LoadBalancer：对外暴露应用，适用公有云</p>
</li>
</ul>
<p>ClusterIP：默认，分配一个稳定的IP地址，即VIP，只能在集群内部访问。</p>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl 10.107.214.48    <span class="comment">#访问集群内部暴露的service的IP及端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4BC1CA5B289A4AABB644197644BFCF13clipboard.png" alt></p>
<p><img src="/images/57A69C2E53F6499B858D3C247528F7B3clipboard.png" alt></p>
<p>NodePort：在每个节点上启用一个端口来暴露服务，可以在集群 外部访问。也会分配一个稳定内部集群IP地址。 访问地址：&lt;任意NodeIP&gt;: 端口范围：30000-32767</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">http://192.168.1.12:30009/  <span class="comment">#访问集群外部节点IP以及暴露的端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/9D738F0AF4584DA38F71D1BC618DE8ACclipboard.png" alt></p>
<p><img src="/images/160A670AE9A44000B53A589FE400605Bclipboard.png" alt></p>
<p>NodePort：会在每台Node上监听端口接收用户流量，在实际情 况下，对用户暴露的只会有一个IP和端口，那这么多台Node该使 用哪台让用户访问呢？</p>
<p>这时就需要前面加一个公网负载均衡器为项目提供统一访问入口了。</p>
<p><img src="/images/D7C5CA3D9A9F4C41BD5E5FFDC2AF08F4clipboard.png" alt></p>
<p>负载均衡器：</p>
<ul>
<li>
<p>开源：nginx、lvs、haproxy</p>
</li>
<li>
<p>公有云：SLB</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream demo &#123;</span><br><span class="line">	server 192.168.0.11:30008;</span><br><span class="line">	server 192.168.0.12:30008;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo2 &#123;</span><br><span class="line">	server 192.168.0.13:30009;</span><br><span class="line">	server 192.168.0.14:30009;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo3 &#123;</span><br><span class="line">	server 192.168.0.15:30010;</span><br><span class="line">	server 192.168.0.16:30010;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name a.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name b.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name c.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadBalancer：与NodePort类似，在每个节点上启用一个端口来暴 露服务。除此之外，Kubernetes会请求底层云平台（例如阿里云、腾 讯云、AWS等）上的负载均衡器，将每个Node （[NodeIP]:[NodePort]）作为后端添加进去。</p>
<p><img src="/images/57137C13B9A640EE8D7C367E149ADB23clipboard.png" alt></p>
<h2 id="Service代理模式">Service代理模式</h2>
<p>Service的底层实现主要有iptables和ipvs二种网络模式，决定了如何转发流量</p>
<p><img src="/images/45B9E4A9C42543FFAE1E1DBF9241EFDEclipboard.png" alt></p>
<p>基于iptables实现负载均衡的一个过程</p>
<p>1、在浏览器访问 <a href="http://192.168.0.11:30009/">http://192.168.0.11:30009/</a></p>
<p>2.数据包经过iptables规则匹配，重定向到另一个链KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p>-A KUBE-NODEPORTS -p tcp -m comment --comment “default/web” -m tcp --dport 30009 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/A0F68B2B033F444B8146083059B79962clipboard.png" alt></p>
<p>3.一组规则，有几个pod就会创建几条规则，这里实现了负载均衡 （概率1/3，1/2，1）</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-PXRBKXV7I65SLLDB</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-4MXWCRSI3HRHILKZ</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -j KUBE-SEP-ODUGDMBPYLOH457E</p>
<p><img src="/images/1423425BFBBC4CF7B8B6547BDB6AA417clipboard.png" alt></p>
<p>4.使用DNAT转发到具体的pod</p>
<p>-A KUBE-SEP-PXRBKXV7I65SLLDB -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.169.133:80</p>
<p><img src="/images/94448BF326BD473983D7823BCE74D6A2clipboard.png" alt></p>
<p>-A KUBE-SEP-4MXWCRSI3HRHILKZ -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.67:80</p>
<p><img src="/images/2DC4797D7765429D852EBB7A5E6C32EEclipboard.png" alt></p>
<p>-A KUBE-SEP-ODUGDMBPYLOH457E -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.68:80</p>
<p><img src="/images/31B2F70ADDAD4CA3AED602FECACBBC56clipboard.png" alt></p>
<p>针对ClusterIP实现的转发，后面与nodeport一样，回到了上面的第三步</p>
<p>-A KUBE-SERVICES -d 10.109.90.58/32 -p tcp -m comment --comment “default/web cluster IP” -m tcp --dport 80 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/3CC81396D80F4171A1FDACC13E9C54D8clipboard.png" alt></p>
<p>kubeadm方式修改ipvs模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit configmaps kube-proxy -n kube-system </span><br><span class="line"><span class="comment">#搜索mode，添加ipvs，修改完保存</span></span><br><span class="line">  mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line"><span class="comment">#删除node1节点proxy的pod,重新生成新的pod</span></span><br><span class="line">kubectl delete pod kube-proxy-lzjgg -n kube-system </span><br><span class="line">kubectl get pod -o wide -n kube-system </span><br><span class="line">kubectl logs kube-proxy-hnw5p -n kube-system </span><br></pre></td></tr></table></figure>
<p><img src="/images/A3F8D2A415C546398858681A0512333Dclipboard.png" alt></p>
<p>注： 1、kube-proxy配置文件以configmap方式存储</p>
<pre><code>     2、如果让所有节点生效，需要重建所有节点kube-proxy pod
</code></pre>
<p>在node1节点上安装ipvsadm工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ipvsadm</span><br><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/9ECAC01183284036B4DFF293FB29FA02clipboard.png" alt></p>
<p>ip a</p>
<p><img src="/images/C1397ED986B04C628380BEFC3B50A968clipboard.png" alt></p>
<p>二进制方式修改ipvs模式：</p>
<p>vi kube-proxy-config.yml</p>
<p>mode: ipvs</p>
<p>ipvs:</p>
<p>scheduler: &quot;rr“</p>
<p>systemctl restart kube-proxy</p>
<p>注：参考不同资料，文件名可能不同</p>
<p>流程包流程：客户端 -&gt;NodePort/ClusterIP（iptables/Ipvs负载均衡规则） -&gt; 分布在各节点Pod</p>
<p>查看负载均衡规则：</p>
<ul>
<li>iptables模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save |grep </span><br></pre></td></tr></table></figure>
<ul>
<li>ipvs模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/48DCC6F8FF224A899C3AF23FC8AD0B8Eclipboard.png" alt></p>
<p>当一个客户端访问service的时候，经过iptables/ipvs进行负载均衡，负载到后端的pod上，iptables/ipvs的规则是由kube-proxy去创建的。</p>
<p>当出现问题的时候，应该先检查的service的配置的是不是对的（标签端口等等），再检查kube-proxy是不是正常的，有没有创建对应的iptables/ipvs规则。</p>
<h2 id="Service-DNS名称">Service DNS名称</h2>
<p>CoreDNS：是一个DNS服务器，Kubernetes默认采用，以Pod部署在集群中，CoreDNS服 务监视Kubernetes API，为每一个Service创建DNS记录用于域名解析。</p>
<p>CoreDNS YAML文件：</p>
<p><a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns">https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns</a></p>
<p>ClusterIP A记录格式：<service-name>.<namespace-name>.svc.cluster.local</namespace-name></service-name></p>
<p>示例：my-svc.my-namespace.svc.cluster.local</p>
<p><img src="/images/ECF12D7CD8F145629E5BF72FD6A79F77clipboard.png" alt></p>
<p><img src="/images/4C475116BD954880B84C0AD18D7301A2clipboard.png" alt></p>
<p>当我们在pod内做nslookup(dns)解析时，它会请求coredns pod，coredns里面存放了从k8smaster中获取的service对应的dns记录，就会帮你解析成对应service的IP。</p>
<p>Iptables VS IPVS</p>
<p>Iptables：</p>
<ul>
<li>
<p>灵活，功能强大</p>
</li>
<li>
<p>规则遍历匹配和更新，呈线性时延</p>
</li>
</ul>
<p>IPVS：</p>
<ul>
<li>
<p>工作在内核态，有更好的性能</p>
</li>
<li>
<p>调度算法丰富：rr，wrr，lc，wlc，ip hash…</p>
</li>
</ul>
<p>生产环境建议使用IPVS</p>
<p>1、创建一个deployment 副本数 3，然后滚动更新镜像版本，并记录这个更新记录，最后再回滚到上一个版本</p>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line"><span class="comment">#通过命令更新镜像，指定--record参数会将这条命令记录到历史版本记录中，方便回滚到对应的版本</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.16 --record  </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl  -I10.244.169.140   <span class="comment">#验证是否是nginx1.16版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web-deployment  <span class="comment">#查看历史版本记录</span></span><br><span class="line">kubectl rollout undo deployment web-deployment  <span class="comment">#默认回滚到上一个版本</span></span><br><span class="line">kubectl get pod -o wide    <span class="comment">#查看pod的IP</span></span><br><span class="line">curl -I 10.244.36.76   <span class="comment">#验证是否回滚到nginx1.15版本</span></span><br></pre></td></tr></table></figure>
<p>2、给一个应用扩容副本数为3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment web-deployment --replicas=6</span><br><span class="line">kubectl get pod </span><br></pre></td></tr></table></figure>
<p>3、创建一个pod，其中运行着nginx、redis、memcached 3个容器</p>
<p>vim nginx-redis-memcached.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-redis-memcached</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis</span><br><span class="line">        image: redis</span><br><span class="line">      containers:</span><br><span class="line">      - name: memcached</span><br><span class="line">        image: memcached</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-redis-memcached.yaml </span><br><span class="line">kubectl get pod</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm nginx -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm redis -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm memcached -- bash</span><br></pre></td></tr></table></figure>
<p>4、给一个pod创建service，并可以通过ClusterIP/NodePort访问</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl  -I 10.105.40.240   <span class="comment">#访问集群内部service IP</span></span><br><span class="line">http://192.168.0.12:30009/    <span class="comment">#访问任意node节点IP加30009端口</span></span><br></pre></td></tr></table></figure>
<p>5、创建deployment和service，使用busybox容器nslookup解析service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it dns-test --image=busybox -- sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/810CBA00E6294D12A8014902A6EC2B6Fclipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/05/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl命令行管理工具</title>
    <url>/2022/06/12/kubectl%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="kubeconfig配置文件">kubeconfig配置文件</h2>
<p>kube-apiserver两个端口：</p>
<ul>
<li>
<p>localhost:8080  非安全端口，是kubectl默认先连接8080，如果你配置kubeconfig（.kube/config）就直接走这个配置连接的安全端口</p>
</li>
<li>
<p>masterip:6443   安全端口</p>
</li>
</ul>
<p>命令行指定配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node --kubeconfig=admin.conf</span><br></pre></td></tr></table></figure>
<p>拷贝认证文件到其他节点的（.kube/config）下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp .kube/config root@192.168.0.12:.kube/</span><br></pre></td></tr></table></figure>
<p>kubectl使用kubeconfig认证文件连接K8s集群， 使用kubectl config指令生成kubeconfig文件。</p>
<p><img src="/images/44B7D7962FFC4A6084E5B03245B92B45clipboard.png" alt></p>
<h2 id="kubectl管理命令概要">kubectl管理命令概要</h2>
<p><img src="/images/B5A0EFF109924D819F7F247722B89244clipboard.png" alt></p>
<p>官方文档参考地址：<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p>
<p><img src="/images/FE0CA664ABC643C6AC7DF7A84860042Cclipboard.png" alt></p>
<h2 id="牛刀小试，快速部署一个网站">牛刀小试，快速部署一个网站</h2>
<p>使用Deployment控制器部署镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=lizhenliang/java-demo </span><br><span class="line">kubectl get deploy,pods</span><br></pre></td></tr></table></figure>
<p>使用Service将Pod暴露出去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment web --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort </span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<p>访问应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://NodeIP:Port <span class="comment"># 端口随机生成，通过get svc获取</span></span><br></pre></td></tr></table></figure>
<h2 id="基本资源概念">基本资源概念</h2>
<ul>
<li>
<p>Pod：K8s最小部署单元，一组容器的集合</p>
</li>
<li>
<p>Deployment：最常见的控制器，用于更高级别部署和管理Pod</p>
</li>
<li>
<p>Service：为一组Pod提供负载均衡，对外提供统一访问入口</p>
</li>
<li>
<p>Label ：标签，附加到某个资源上，用于关联对象、查询和筛选</p>
</li>
<li>
<p>Namespaces ：命名空间，将对象逻辑上隔离，也利于权限控制</p>
</li>
</ul>
<h2 id="命名空间">命名空间</h2>
<p>命名空间（Namespace）：Kubernetes将资源对象逻辑上隔离，从而形成多个虚拟集群。</p>
<p>应用场景：</p>
<ul>
<li>
<p>根据不同团队划分命名空间</p>
</li>
<li>
<p>根据项目划分命名空间</p>
</li>
</ul>
<p>kubectl get namespace</p>
<ul>
<li>
<p>default：默认命名空间</p>
</li>
<li>
<p>kube-system：K8s系统方面的命名空间</p>
</li>
<li>
<p>kube-public：公开的命名空间，谁都可以访问，</p>
</li>
<li>
<p>kube-node-lease：K8s内部命名空间</p>
</li>
</ul>
<p>两种方法指定资源命名空间：</p>
<ul>
<li>
<p>命令行加 -n</p>
</li>
<li>
<p>yaml资源元数据里指定namespace字段</p>
</li>
</ul>
<p>1、使用kubeadm搭建一个K8s集群</p>
<p>2、新建命名空间，在该命名空间中创建一个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace azhe</span><br></pre></td></tr></table></figure>
<p>3、创建一个deployment并暴露Service，可以在浏览器访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment java-demo --image=lizhenliang/java-demo -n azhe </span><br><span class="line">kubectl expose deployment java-demo --port 80 --target-port=8080 --<span class="built_in">type</span>=NodePort  -n azhe </span><br></pre></td></tr></table></figure>
<p>4、列出命名空间下指定标签pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n azhe --show-labels</span><br><span class="line">kubectl get pod -l app=java-demo -n azhe </span><br><span class="line">kubectl get pod,svc,deploy -o wide -n azhe  <span class="comment">#查看azhe命名空间下的pod，svc,deploy资源</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4D8950519EAC4C08B9D400C984FD4308clipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker构建企业Jenkins平台</title>
    <url>/2022/05/27/%E5%9F%BA%E4%BA%8EDocker%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9AJenkins%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>CI/CD概述</p>
<p>持续集成（Continuous Integration，CI）：代码合并、构建、部署、测试都在一起，不断地执行这个过程，并对结果反馈。</p>
<p>持续部署（Continuous Deployment，CD）：部署到测试环境、预生产环境、生产环境。</p>
<p>持续交付（Continuous Delivery，CD）：将最终产品发布到生产环境，给用户使用。</p>
<p><img src="/images/D06234A999FE473FBA13400A79F2390Aclipboard.png" alt></p>
<p>CI工作流程设计</p>
<p><img src="/images/3C3FFAC3EFE24641B2E3746166FFDD5Eclipboard.png" alt></p>
<p>开发者提交代码到gitlab仓库，gitlab随后触发jenkins代码编译，构建镜像以及推送镜像到harbor仓库，紧接着Jenkins部署到docker主机（从harbor仓库拉取镜像到本地部署启动）。</p>
<table>
<thead>
<tr>
<th>gitlab主机</th>
<th>jenkins主机</th>
<th>harbor主机</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.11/24</td>
<td>192.168.0.13/24</td>
<td>192.168.0.12/24</td>
</tr>
</tbody>
</table>
<pre><code>                                                       项目环境表
</code></pre>
<p>1、部署Gitlab</p>
<p>1.1 部署Gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gitlab</span><br><span class="line"><span class="built_in">cd</span> gitlab</span><br><span class="line">docker run -d \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  -p 8443:443 \</span><br><span class="line">  -p 9999:80 \</span><br><span class="line">  -p 9998:22 \</span><br><span class="line">  -v <span class="variable">$PWD</span>/config:/etc/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/logs:/var/log/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/data:/var/opt/gitlab \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  --restart=always \</span><br><span class="line">  lizhenliang/gitlab-ce-zh:latest</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP:9999">http://IP:9999</a></p>
<p>初次会先设置管理员密码 ，然后登陆，默认管理员用户名root，密码就是刚设置的。</p>
<p>1.2 创建项目，提交测试代码</p>
<p>进入后先创建项目，提交代码，以便后面测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip tomcat-java-demo-master.zip</span><br><span class="line"><span class="built_in">cd</span> tomcat-java-demo-master</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://192.168.0.11:9999/root/java-demo.git</span><br><span class="line">git add .</span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git commit -m <span class="string">&#x27;all&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>2、部署Harbor镜像仓库</p>
<p>2.1 安装docker与docker-compose</p>
<p>2.2 解压离线包部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v2.0.0.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># cp harbor.yml.tmpl harbor.yml</span></span><br><span class="line"><span class="comment"># vi harbor.yml</span></span><br><span class="line">hostname: reg.ctnrs.com</span><br><span class="line">https:   <span class="comment"># 先注释https相关配置</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh</span></span><br></pre></td></tr></table></figure>
<p>2.3 在Jenkins主机配置Docker可信任，如果是HTTPS需要拷贝证书</p>
<p>由于habor未配置https，还需要在docker配置可信任。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.0.12&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>2.4 构建tomcat镜像并上传到harbor仓库上（供jenkinsfile脚本调用）</p>
<p>#准备的安装包（apache-tomcat-8.5.43.tar.gz）和Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建并上传到harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.0.12/library/tomcat:v1 .</span><br><span class="line">docker login 192.168.0.12</span><br><span class="line">docker /images</span><br><span class="line">docker push 192.168.0.12/library/tomcat:v1</span><br></pre></td></tr></table></figure>
<p><img src="/images/725360157F1C4DF0B88A2EDA4C641CA8clipboard.png" alt></p>
<p>3、部署Jenkins</p>
<p>3.1 准备JDK和Maven环境</p>
<p>将二进制包上传到服务器并解压到工作目录，用于让Jenkins容器挂载使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf jdk-8u45-linux-x64.tar.gz</span></span><br><span class="line"><span class="comment"># mv jdk1.8.0_45 /usr/local/jdk</span></span><br><span class="line"><span class="comment"># tar zxf apache-maven-3.5.0-bin.tar.gz</span></span><br><span class="line"><span class="comment"># mv apache-maven-3.5.0 /usr/local/maven</span></span><br></pre></td></tr></table></figure>
<p>修改Maven源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/maven/conf/setting.xml</span><br><span class="line"></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line"></span><br><span class="line">&lt;mirror&gt;     </span><br><span class="line">  &lt;<span class="built_in">id</span>&gt;central&lt;/id&gt;     </span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     </span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;     </span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>
<p>部署jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 80:8080 -p 50000:50000 -u root  \</span><br><span class="line">   -v /opt/jenkins_home:/var/jenkins_home \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock   \</span><br><span class="line">   -v /usr/bin/docker:/usr/bin/docker \</span><br><span class="line">   -v /usr/local/maven:/usr/local/maven \</span><br><span class="line">   -v /usr/local/jdk:/usr/local/jdk \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP">http://IP</a></p>
<p>3.2 安装插件</p>
<p>管理Jenkins-&gt;系统配置–&gt;管理插件**–&gt;搜索git/pipeline，选中点击安装。</p>
<p>默认从国外网络下载插件，会比较慢，建议修改国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jenkins_home/updates</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>
<p>3.3 Jenkins Pipeline介绍</p>
<p>Jenkins Pipeline是一套插件，支持在Jenkins中实现集成和持续交付管道；</p>
<p>Pipeline通过特定语法对简单到复杂的传输管道进行建模；</p>
<p>声明式：遵循与Groovy相同语法。pipeline { }</p>
<p>脚本式：支持Groovy大部分功能，也是非常表达和灵活的工具。node { }</p>
<p>Jenkins Pipeline的定	义被写入一个文本文件，称为Jenkinsfile。</p>
<p><img src="/images/A721BDDA11234FEFBB2D6AFBA3C673CAclipboard.png" alt></p>
<p><img src="/images/3EAC878934A84E509B25BFCF9A463E62clipboard.png" alt></p>
<p><img src="/images/A3A3BF02751C4D79B7ACEC54F86C0CDFclipboard.png" alt></p>
<p>注意： 发布之前可以在jenkins主机上测试一下是否能登录harbor仓库</p>
<p>如果不能登录报错为连接443拒绝，那么请使用以下方式解决：</p>
<p>修改Docker启动文件添加“–insecure-registry 192.168.0.12”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 192.168.0.12</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4、发布测试</p>
<p>4.1添加连接git仓库凭据和harbor仓库凭据</p>
<p>管理Jenkins-&gt;安全–&gt;管理凭据-&gt;Jnekins-&gt;添加凭据-&gt;Username with password</p>
<ul>
<li>
<p>Username：用户名</p>
</li>
<li>
<p>Password：密码</p>
</li>
<li>
<p>ID：留空</p>
</li>
<li>
<p>Description：描述</p>
</li>
</ul>
<p>分别添加连接git和harbor凭据，并修改脚本为实际凭据ID。</p>
<p><img src="/images/028FE8C5C63C44E19CBEECC88334DC65clipboard.png" alt></p>
<p>4.2 创建项目并配置</p>
<p>New Item -&gt; Pipeline -&gt; This project is parameterized -&gt; String Parameter</p>
<ul>
<li>
<p>Name：Branch    # 变量名，下面脚本中调用</p>
</li>
<li>
<p>Default Value：master   # 默认分支</p>
</li>
<li>
<p>Description：发布的代码分支  # 描述</p>
</li>
</ul>
<p><img src="/images/7A9EA62F8A9F4D97991A4AB427F6EDC5clipboard.png" alt></p>
<p>4.3 Pipeline脚本（在Jenkins本地机器上部署并启动容器）</p>
<p>一. 添加注释方便查看使用说明（添加注释到jenkins执行会报错，请使用第二个构建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      <span class="comment">#harbor仓库地址</span></span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                <span class="comment">#harbor仓库项目名</span></span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>         <span class="comment">#镜像的应用名</span></span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>  <span class="comment">#Branch代表引用的分支名</span></span><br><span class="line">                                                                                 <span class="comment">#BUILD_NUMBER代表构建编号</span></span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>        <span class="comment">#git仓库连接地址</span></span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>      <span class="comment">#harbor仓库认证（用户名和密码）</span></span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  <span class="comment">#git仓库认证（用户名和密码）</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二.请使用这个pipeline脚本构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  </span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述脚本中，docker_registry_auth 和git_auth变量的值为Jenkins凭据ID，添加凭据后修改。</p>
<p>4.4 Pipeline脚本（ 在其他的Docker主机上部署并启动容器）</p>
<p>安装jenkins插件</p>
<p>插件名称： SSH Pipeline Steps</p>
<p>使用说明: <a href="https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps">https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>   </span><br><span class="line">def remote = [:]</span><br><span class="line">    remote.name = <span class="string">&quot;test&quot;</span></span><br><span class="line">    remote.host = <span class="string">&quot;192.168.0.12&quot;</span></span><br><span class="line">    remote.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    remote.password = <span class="string">&#x27;123.com&#x27;</span></span><br><span class="line">    remote.allowAnyHosts = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sshCommand remote: remote, <span class="built_in">command</span>: <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                ip a</span></span><br><span class="line"><span class="string">                docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">                docker pull <span class="variable">$&#123;image_name&#125;</span> </span></span><br><span class="line"><span class="string">                docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">               &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p>1.访问harbor仓库查看是否有上传的镜像    <a href="http://192.168.0.12/">http://192.168.0.12/</a></p>
<p><img src="/images/04418B7661DC49D1AD92114AC38F5A64clipboard.png" alt></p>
<p>2.docker主机上运行的项目镜像容器</p>
<p><img src="/images/03E31D0090E748B5B3B8416B4C4EEC4Cclipboard.png" alt></p>
<p>3.访问部署java-demo示例     <a href="http://192.168.0.13:88/">http://192.168.0.13:88/</a></p>
<p><img src="/images/5DF2722940214B15AB62A6AA70E96839clipboard.png" alt></p>
<p>CI/CD收益</p>
<p>高效的CI/CD环境可以获得：</p>
<p>1.及时发现问题</p>
<p>2.大幅度减少故障率</p>
<p>3.加快迭代速度</p>
<p>4.减少时间成本</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Docker容器多主机通信</title>
    <url>/2022/05/26/%E5%AE%9E%E7%8E%B0Docker%E5%AE%B9%E5%99%A8%E5%A4%9A%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>跨主机网络：实现Docker容器多主机通信</p>
<p>Flannel是CoreOS维护的一个网络组件，在每个主机上运行守护 进程负责维护本地路由转发，Flannel使用ETCD来存储容器网络 与主机之前的关系。</p>
<p>其他主流容器跨主机网络方案：</p>
<p>• Weave</p>
<p>• Calico</p>
<p>• OpenvSwitch</p>
<p><img src="/images/10B81BDFE6B2495FB1B335FAC555BF8Dclipboard.png" alt></p>
<p>1、etcd安装并配置（任意找一台节点安装即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install etcd</span><br><span class="line">vim /etc/etcd/etcd.conf </span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;default&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line">ss -anpt |grep 2379</span><br></pre></td></tr></table></figure>
<p>2、flanneld安装并配置（两台跨主机的docker主机安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install flannel</span><br><span class="line">vim /etc/sysconfig/flanneld</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">FLANNEL_ETCD_PREFIX=<span class="string">&quot;/atomic.io/network&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、向etcd写入子网启动并flanneld服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> <span class="built_in">set</span> /atomic.io/network/config <span class="string">&#x27;&#123; &quot;Network&quot;:&quot;172.17.0.0/16&quot;, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125; &#x27;</span></span><br><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> get /atomic.io/network/config </span><br><span class="line">systemctl start flanneld.service  </span><br><span class="line">systemctl <span class="built_in">enable</span> flanneld.service </span><br></pre></td></tr></table></figure>
<p>4、配置Docker使用flannel生成的网络信息 (两台跨主机的docker主机配置）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line">EnvironmentFile=/var/run/flannel/docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock <span class="variable">$DOCKER_NETWORK_OPTIONS</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker </span><br><span class="line">ps -ef |grep docker</span><br></pre></td></tr></table></figure>
<p>5.两台跨主机的docker主机设置iptable转发策略为允许并重启服务（按顺序启动）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">systemctl restart flanneld.service </span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<p>6、在两台主机创建容器相互ping验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it busybox sh</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure>
<p>防火墙学习：</p>
<p><a href="https://www.cnblogs.com/shijiaqi1066/p/3812510.html">https://www.cnblogs.com/shijiaqi1066/p/3812510.html</a></p>
<p><a href="http://www.zsythink.net/archives/1199">http://www.zsythink.net/archives/1199</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>容器化搭建个人博客系统</title>
    <url>/2022/05/28/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Dockerfile涉及相关的文件及安装包</p>
<p><a href="/attachments/F00C39A38A9E42F1B5B1DB1B3DA7CB4Adockerfile.zip">dockerfile.zip</a></p>
<p><img src="/images/418306A840FE4995A255CA27354E9163clipboard.png" alt></p>
<p>前端项目镜像构建与部署：Nginx</p>
<p>nginx目录文件: 1.Dockerfile 2.nginx-1.15.5.tar.gz 3.nginx.conf4.php.conf</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">RUN yum install -y gcc gcc-c++ make \</span><br><span class="line">    openssl-devel pcre-devel gd-devel \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD nginx-1.15.5.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> nginx-1.15.5 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/nginx \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_stub_status_module &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/nginx/conf/vhost &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf nginx* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/nginx/sbin</span><br><span class="line">COPY nginx.conf /usr/local/nginx/conf/nginx.conf</span><br><span class="line">WORKDIR /usr/local/nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user                 nobody;</span><br><span class="line">worker_processes     4;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log  notice;</span><br><span class="line"></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  4096;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    client_max_body_size         64m;</span><br><span class="line">    include /usr/local/nginx/conf/vhost/*.conf;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        index index.html;</span><br><span class="line">        access_log logs/access.log;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>php.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.ctnrs.com;</span><br><span class="line">    index index.php index.html;</span><br><span class="line"></span><br><span class="line">    access_log logs/www.ctnrs.com_access.log;</span><br><span class="line">    error_log logs/www.ctnrs.com_error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.php$ &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">        fastcgi_pass lnmp_php:9000;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PHP项目镜像构建：PHP</p>
<p>php目录文件: 1.Dockerfile 2.php-5.6.36.tar.gz 3.php-fpm.conf  4.php.ini</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line">RUN yum install epel-release -y &amp;&amp; \</span><br><span class="line">    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \</span><br><span class="line">    libcurl-devel libjpeg-devel libpng-devel openssl-devel \</span><br><span class="line">    libmcrypt-devel libxslt-devel libtidy-devel autoconf \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD php-5.6.36.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> php-5.6.36 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/php \</span><br><span class="line">    --with-config-file-path=/usr/local/php/etc \</span><br><span class="line">    --enable-fpm --enable-opcache \</span><br><span class="line">    --with-mysql --with-mysqli --with-pdo-mysql \</span><br><span class="line">    --with-openssl --with-zlib --with-curl --with-gd \</span><br><span class="line">    --with-jpeg-dir --with-png-dir --with-freetype-dir \</span><br><span class="line">    --enable-mbstring --with-mcrypt --enable-hash &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> php.ini-production /usr/local/php/etc/php.ini &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> sapi/fpm/php-fpm.conf /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&quot;90a \daemonize = no&quot;</span> /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/php/log &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf php* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/php/sbin</span><br><span class="line">COPY php.ini /usr/local/php/etc/</span><br><span class="line">COPY php-fpm.conf /usr/local/php/etc/</span><br><span class="line">WORKDIR /usr/local/php</span><br><span class="line">EXPOSE 9000</span><br><span class="line">CMD [<span class="string">&quot;php-fpm&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器化搭建个人博客系统</p>
<p>1、自定义网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create lnmp</span><br></pre></td></tr></table></figure>
<p>2、创建Mysql容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_mysql --net lnmp --mount src=mysql-vol,dst=/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=wordpress mysql:5.7 --character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p>3、创建PHP容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_php --net lnmp --mount src=wwwroot,dst=/wwwroot php:v1</span><br></pre></td></tr></table></figure>
<p>4、创建Nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_nginx --net lnmp -p 88:80 --mount src=wwwroot,dst=/wwwroot --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=<span class="variable">$PWD</span>/php.conf,dst=/usr/local/nginx/conf/vhost/php.conf nginx:v1</span><br></pre></td></tr></table></figure>
<p>5、访问php网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">vim test.php</span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88/test.php</span><br></pre></td></tr></table></figure>
<p>6.以wordpress博客为例</p>
<p><a href="/attachments/DA30ED5D4B2C4750AEA183252F67A445wordpress-4.9.4-zh_CN.tar.gz">wordpress-4.9.4-zh_CN.tar.gz</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">tar -zxf wordpress-4.9.4-zh_CN.tar.gz</span><br><span class="line"><span class="built_in">mv</span> wordpress/* .</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88</span><br></pre></td></tr></table></figure>
<p><img src="/images/691AF1100B69430F9FF94B594939ED9Eclipboard.png" alt></p>
<p><img src="/images/AA9191C1DDFA433D88B7445EB109505Dclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工作负载控制器</title>
    <url>/2022/06/16/%E5%B8%B8%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="工作负载控制器是什么">工作负载控制器是什么</h2>
<p>工作负载控制器（Workload Controllers）是K8s的一个抽象概念，用于更高级层次对象，部署和管理Pod。</p>
<p>常用工作负载控制器：</p>
<ul>
<li>
<p>Deployment ： 无状态应用部署</p>
</li>
<li>
<p>StatefulSet ： 有状态应用部署</p>
</li>
<li>
<p>DaemonSet ： 确保所有Node运行同一个Pod</p>
</li>
<li>
<p>Job ： 一次性任务</p>
</li>
<li>
<p>Cronjob ： 定时任务</p>
</li>
</ul>
<p>控制器的作用：</p>
<ul>
<li>
<p>管理Pod对象</p>
</li>
<li>
<p>使用标签与Pod关联</p>
</li>
<li>
<p>控制器实现了Pod的运维，例如滚动更新、伸缩、副本管理、维护Pod状态等。</p>
</li>
</ul>
<p><img src="/images/57989713257848DF8CDF41CBAA91FBB1clipboard.png" alt></p>
<h2 id="Deployment">Deployment</h2>
<h3 id="Deployment：介绍">Deployment：介绍</h3>
<p>Deployment的功能：</p>
<ul>
<li>
<p>管理Pod和ReplicaSet</p>
</li>
<li>
<p>具有上线部署、副本设定、滚动升级、回滚等功能</p>
</li>
<li>
<p>提供声明式更新，例如只更新一个新的Image 应用场景：网站、API、微服务</p>
</li>
</ul>
<h3 id="Deployment：使用流程">Deployment：使用流程</h3>
<p><img src="/images/7FCAD8175D234694B295C4780BB764D3clipboard.png" alt></p>
<h3 id="Deployment：部署">Deployment：部署</h3>
<p>第一步：部署镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl create deployment web --image=nginx:1.15</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发布并访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line">kubectl expose deployment web-deployment --port 80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：滚动升级">Deployment：滚动升级</h3>
<p>第二步：应用升级（更新镜像三种方式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/web nginx=nginx:1.16 </span><br><span class="line">kubectl edit deployment/web</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.17</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 10   <span class="comment">#启动容器后多少秒开始检查</span></span><br><span class="line">          periodSeconds: 10      <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/3C61282B9CE64C02BCE02AC6E40E5605clipboard.png" alt></p>
<p>滚动升级：K8s对Pod升级的默认策略，通过使 用新版本Pod逐步更新旧版本Pod，实现零停机 发布，用户无感知。</p>
<p>滚动升级在K8s中的实现：</p>
<ul>
<li>
<p>1个Deployment</p>
</li>
<li>
<p>2个ReplicaSet</p>
</li>
</ul>
<p><img src="/images/9425F7FDCFEE49FE94E6D37E0A26B8C6clipboard.png" alt></p>
<ul>
<li>
<p>maxSurge：滚动更新过程中最大Pod副本数，确保在更新时启动的Pod数 量比期望（replicas）Pod数量最大多出25%</p>
</li>
<li>
<p>maxUnavailable：滚动更新过程中最大不可用Pod副本数，确保在更新时 最大25% Pod数量不可用，即确保75% Pod数量是可用状态。</p>
</li>
</ul>
<p><img src="/images/CD4FE9677984427DA97042EDB93D8695clipboard.png" alt></p>
<h3 id="Deployment：水平扩缩容">Deployment：水平扩缩容</h3>
<p>第三步：水平扩缩容（启动多实例，提高并发）</p>
<ul>
<li>
<p>修改yaml里replicas值，再apply</p>
</li>
<li>
<p>kubectl scale deployment web --replicas=10</p>
</li>
</ul>
<p>注：replicas参数控制Pod副本数量</p>
<p><img src="/images/C5A8BEFC58CA473986D5DBF11B8246F7clipboard.png" alt></p>
<h3 id="Deployment：回滚">Deployment：回滚</h3>
<p>第四步：回滚（发布失败恢复正常版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment/web <span class="comment"># 查看历史发布版本 </span></span><br><span class="line">kubectl rollout undo deployment/web <span class="comment"># 默认回滚上一个版本 </span></span><br><span class="line">kubectl rollout undo deployment/web --to-revision=2 <span class="comment"># 回滚历史指定版本</span></span><br></pre></td></tr></table></figure>
<p>注：回滚是重新部署某一次部署时的状态，即当时版本所有配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.19 --record  <span class="comment">#升级</span></span><br><span class="line">kubectl rollout undo deployment web-deployment --to-revision=7  <span class="comment">#回滚到指定版本</span></span><br><span class="line">kubectl get rs -o wide</span><br><span class="line">kubectl describe rs web-deployment-5449cf89f </span><br></pre></td></tr></table></figure>
<h3 id="Deployment：删除">Deployment：删除</h3>
<p>最后，项目下线：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete deploy/web </span><br><span class="line">kubectl delete svc/web</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：ReplicaSet">Deployment：ReplicaSet</h3>
<p>ReplicaSet控制器用途：</p>
<ul>
<li>
<p>Pod副本数量管理，不断对比当前Pod数量与期望Pod数量</p>
</li>
<li>
<p>Deployment每次发布都会创建一个RS作为记录，用于实现回滚</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get rs <span class="comment">#查看RS记录 </span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web <span class="comment">#版本对应RS记录</span></span><br><span class="line">kubectl describe rs |egrep -i <span class="string">&quot;revision|image&quot;</span>  <span class="comment">#查看版本对应的镜像</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/F05204D400AC49BD984EC2F32E0FB304clipboard.png" alt></p>
<h2 id="DaemonSet">DaemonSet</h2>
<p>DaemonSet功能：</p>
<ul>
<li>
<p>在每一个Node上运行一个Pod</p>
</li>
<li>
<p>新加入的Node也同样会自动运行一个Pod</p>
</li>
</ul>
<p>应用场景：网络插件（kube-proxy、calico）、其他Agent</p>
<p><img src="/images/8D4FD2F4A8E3450CB224EABA85A1F388clipboard.png" alt></p>
<p>示例：部署一个日志采集程序</p>
<p>vim daemonset.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet        </span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: filebeat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: filebeat</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:               </span><br><span class="line">      - effect: NoSchedule        <span class="comment">#配置污点容忍，确保分配到每个节点</span></span><br><span class="line">        operator: Exists  <span class="comment">#没有配置键值形式，节点上只要有NoSchedule策略，只要存在就容忍</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: <span class="built_in">log</span></span><br><span class="line">        image: elastic/filebeat:7.3.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f daemonset.yaml </span><br><span class="line">kubectl get daemonsets.apps -n kube-system  <span class="comment">#查看使用daemonset控制器的pod</span></span><br><span class="line">kubectl get daemonsets.apps calico-node -o yaml -n kube-system | grep tor </span><br><span class="line">kubectl get pod -n kube-system -o wide  <span class="comment">#确保在每个节点都启动一个日志采集器pod   </span></span><br></pre></td></tr></table></figure>
<h2 id="Job">Job</h2>
<p>Job分为普通任务（Job）和定时任务（CronJob）</p>
<ul>
<li>一次性执行</li>
</ul>
<p>应用场景：离线数据处理，视频解码等业务</p>
<p>vim job.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi</span><br><span class="line">        image: perl</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;perl&quot;</span>, <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      restartPolicy: Never         <span class="comment">#执行完容器就退出</span></span><br><span class="line">  backoffLimit: 4 <span class="comment"># 重试次数</span></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f job.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get pod    <span class="comment">#complete状态，需要主动删除pod</span></span><br><span class="line">kubectl logs pi-z7rrb </span><br></pre></td></tr></table></figure>
<h2 id="CronJob">CronJob</h2>
<p>CronJob用于实现定时任务，像Linux的Crontab一样。</p>
<ul>
<li>定时任务 应用场景：通知，备份</li>
</ul>
<p>vim cronjob.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">&quot;*/1 * * * *&quot;</span>     <span class="comment">#跟Linux的crontab一样写法</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="built_in">date</span>; <span class="built_in">echo</span> Hello azhe</span><br><span class="line">          restartPolicy: OnFailure   <span class="comment">#如果执行上面的命令失败返回状态码非0会帮你重启容器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f cronjob.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get cronjob</span><br><span class="line">kubectl logs hello-1613720220-ldb7z </span><br></pre></td></tr></table></figure>
<p><img src="/images/E705E25E66D840228B054BA469DE8828clipboard.png" alt></p>
<p><img src="/images/8FC4E782A0F040F3A6A2F40F0581134Fclipboard.png" alt></p>
<p><img src="/images/57136FADCE894FA7BF380678271AD152clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>快速部署一个K8s集群</title>
    <url>/2022/06/11/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAK8s%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="生产环境部署K8s的2种方式">生产环境部署K8s的2种方式</h2>
<h4 id="kubeadm">kubeadm</h4>
<p>Kubeadm是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p>
<p>部署地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<h4 id="二进制">二进制</h4>
<p>推荐，从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>下载地址：<a href="https://github.com/kubernetes/kubernetes/releases">https://github.com/kubernetes/kubernetes/releases</a></p>
<h2 id="服务器硬件配置推荐">服务器硬件配置推荐</h2>
<p><img src="/images/2AB14DBE37A14CEB9A1838BE07C1D5F5clipboard.png" alt></p>
<h2 id="使用kubeadm快速部署一个K8s集群">使用kubeadm快速部署一个K8s集群</h2>
<table>
<thead>
<tr>
<th>192.168.0.11/24</th>
<th>192.168.0.12/24</th>
<th>192.168.0.13/24</th>
</tr>
</thead>
<tbody>
<tr>
<td>k8s-master</td>
<td>k8s-node1</td>
<td>k8s-node2</td>
</tr>
</tbody>
</table>
<p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Master 节点</span></span><br><span class="line">$ kubeadm init</span><br><span class="line"><span class="comment"># 将一个 Node 节点加入到当前集群中</span></span><br><span class="line">$ kubeadm <span class="built_in">join</span> &lt;Master节点的IP和端口 &gt;</span><br></pre></td></tr></table></figure>
<p>master：kube-apiserver、scheduler、controller-manager、etcd</p>
<p>node：kubelet（非容器化）、kube-proxy</p>
<p>kubeadm不单纯是简化部署k8s集群，采用了容器化方式部署k8s组件。</p>
<h3 id="1-安装要求">1. 安装要求</h3>
<p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p>
<ul>
<li>
<p>一台或多台机器，操作系统 CentOS7.x-86_x64</p>
</li>
<li>
<p>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</p>
</li>
<li>
<p>集群中所有机器之间网络互通</p>
</li>
<li>
<p>可以访问外网，需要拉取镜像</p>
</li>
<li>
<p>禁止swap分区</p>
</li>
</ul>
<h3 id="2-准备环境">2. 准备环境</h3>
<h4 id="关闭防火墙：">关闭防火墙：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
<h4 id="关闭selinux：">关闭selinux：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久</span></span><br><span class="line">$ setenforce 0  <span class="comment"># 临时</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭swap：">关闭swap：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swapoff -a  <span class="comment"># 临时</span></span><br><span class="line">$ vim /etc/fstab  <span class="comment"># 永久</span></span><br></pre></td></tr></table></figure>
<h4 id="设置主机名：">设置主机名：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在master添加hosts：">在master添加hosts：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.0.11 k8s-master</span></span><br><span class="line"><span class="string">192.168.0.12 k8s-node1</span></span><br><span class="line"><span class="string">192.168.0.13 k8s-node2</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="将桥接的IPv4流量传递到iptables的链：">将桥接的IPv4流量传递到iptables的链：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ sysctl --system  <span class="comment"># 生效</span></span><br></pre></td></tr></table></figure>
<h4 id="时间同步：">时间同步：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install ntpdate -y</span><br><span class="line">$ ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h3 id="3-安装Docker-kubeadm-kubelet【所有节点】">3. 安装Docker/kubeadm/kubelet【所有节点】</h3>
<p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p>
<h4 id="3-1-安装Docker">3.1 安装Docker</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">$ yum -y install docker-ce</span><br><span class="line">$ systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>
<p>配置镜像下载加速器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ systemctl restart docker</span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
<h4 id="3-2-添加阿里云YUM软件源">3.2 添加阿里云YUM软件源</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-安装kubeadm，kubelet和kubectl">3.3 安装kubeadm，kubelet和kubectl</h4>
<p>由于版本更新频繁，这里指定版本号部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y kubelet-1.19.0 kubeadm-1.19.0 kubectl-1.19.0</span><br><span class="line">$ systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h3 id="4-部署Kubernetes-Master">4. 部署Kubernetes Master</h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file</a></p>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node</a></p>
<p>在192.168.0.11（Master）执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm init \	</span><br><span class="line">  --apiserver-advertise-address=192.168.0.11 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.19.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>–apiserver-advertise-address 集群通告地址</p>
</li>
<li>
<p>–image-repository  由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</p>
</li>
<li>
<p>–kubernetes-version K8s版本，与上面安装的一致</p>
</li>
<li>
<p>–service-cidr 集群内部虚拟网络，Pod统一访问入口</p>
</li>
<li>
<p>–pod-network-cidr Pod网络，，与下面部署的CNI网络组件yaml中保持一致</p>
</li>
</ul>
<p>kubeadm init初始化工作：</p>
<p>1、[preflight] 环境检查和拉取镜像 kubeadm config /images pull</p>
<p>2、[certs] 生成k8s证书和etcd证书 /etc/kubernetes/pki</p>
<p>3、[kubeconfig] 生成kubeconfig文件</p>
<p>4、[kubelet-start] 生成kubelet配置文件</p>
<p>5、[control-plane] 部署管理节点组件，用镜像启动容器  kubectl get pods -n kube-system</p>
<p>6、[etcd] 部署etcd数据库，用镜像启动容器</p>
<p>7、[upload-config] [kubelet] [upload-certs] 上传配置文件到k8s中</p>
<p>8、[mark-control-plane] 给管理节点添加一个标签 <a href="http://node-role.kubernetes.io/master=">node-role.kubernetes.io/master=</a>‘’，再添加一个污点[<a href="http://node-role.kubernetes.io/master:NoSchedule">node-role.kubernetes.io/master:NoSchedule</a>]</p>
<p>9、[bootstrap-token] 自动为kubelet颁发证书</p>
<p>10、[addons] 部署插件，CoreDNS、kube-proxy</p>
<p>或者使用配置文件引导：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi kubeadm.conf</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.0</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers </span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16 </span><br><span class="line">  serviceSubnet: 10.96.0.0/12 </span><br><span class="line">  </span><br><span class="line">$ kubeadm init --config kubeadm.conf --ignore-preflight-errors=all  </span><br></pre></td></tr></table></figure>
<p>拷贝kubectl使用的连接k8s认证文件到默认路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   2m   v1.18.0</span><br></pre></td></tr></table></figure>
<h3 id="5-加入Kubernetes-Node">5. 加入Kubernetes Node</h3>
<p>在192.168.0.11/12（Node）执行。</p>
<p>向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token dq52g0.m44tucwrwwyieklo \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:0f9df6b112b8bd2ca31c6ccfa777ab057158774bd68990e84393b50e0f181572 </span><br></pre></td></tr></table></figure>
<p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm token create</span><br><span class="line">$ kubeadm token list</span><br><span class="line">$ openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span></span><br><span class="line">63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br><span class="line"></span><br><span class="line">$ kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token nuja6n.o3jrhsffiqs9swnu --discovery-token-ca-cert-hash sha256:63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br></pre></td></tr></table></figure>
<p>或者直接命令快捷生成：kubeadm token create --print-join-command</p>
<p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/</a></p>
<h3 id="6-部署容器网络（CNI）">6. 部署容器网络（CNI）</h3>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network</a></p>
<p>注意：只需要部署下面其中一个，推荐Calico。</p>
<p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。</p>
<p>Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的虚拟路由器（ vRouter） 来负责数据转发，而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。</p>
<p>此外，Calico  项目还实现了 Kubernetes 网络策略，提供ACL功能。</p>
<p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart">https://docs.projectcalico.org/getting-started/kubernetes/quickstart</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>
<p>下载完后还需要修改里面定义Pod网络（CALICO_IPV4POOL_CIDR），与前面kubeadm init指定的一样</p>
<p>修改完后应用清单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f calico.yaml</span><br><span class="line">$ kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>
<h3 id="7-测试kubernetes集群">7. 测试kubernetes集群</h3>
<ul>
<li>
<p>验证Pod工作</p>
</li>
<li>
<p>验证Pod网络通信</p>
</li>
<li>
<p>验证DNS解析</p>
</li>
</ul>
<p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create deployment nginx --image=nginx</span><br><span class="line">$ kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">$ kubectl get pod,svc</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://NodeIP">http://NodeIP</a>:Port</p>
<h3 id="8-部署-Dashboard">8. 部署 Dashboard</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.3/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi recommended.yaml</span><br><span class="line">...</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">...</span><br><span class="line">$ kubectl apply -f recommended.yaml</span><br><span class="line">$ kubectl get pods -n kubernetes-dashboard</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-6b4884c9d5-gl8nr   1/1     Running   0          13m</span><br><span class="line">kubernetes-dashboard-7f99b75bf4-89cds        1/1     Running   0          13m</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="https://NodeIP:30001">https://NodeIP:30001</a></p>
<p>创建service account并绑定默认cluster-admin管理员集群角色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">$ kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line"><span class="comment"># 用户授权</span></span><br><span class="line">$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line"><span class="comment"># 获取用户Token</span></span><br><span class="line">$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk <span class="string">&#x27;/dashboard-admin/&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用输出的token登录Dashboard。</p>
<p><img src="/images/268C8E2AC7224A1C8F6A0BC88B9B1A0Cclipboard.png" alt></p>
<h2 id="K8s-CNI网络模型">K8s CNI网络模型</h2>
<p><img src="/images/77DF44AB43FB4CA0BA6CEF859FCE5CF3clipboard.png" alt></p>
<p>K8s是一个扁平化网络。</p>
<p>即所有部署的网络组件都必须满足如下要求：</p>
<ul>
<li>
<p>一个Pod一个IP</p>
</li>
<li>
<p>所有的 Pod 可以与任何其他 Pod 直接通信</p>
</li>
<li>
<p>所有节点可以与所有 Pod 直接通信</p>
</li>
<li>
<p>Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个</p>
</li>
</ul>
<p>主流网络组件有：Flannel、Calico等</p>
<h2 id="查看集群状态">查看集群状态</h2>
<h4 id="查看master组件状态：">查看master组件状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs </span><br></pre></td></tr></table></figure>
<h4 id="查看node状态：">查看node状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure>
<h4 id="查看Apiserver代理的URL：">查看Apiserver代理的URL：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info </span><br></pre></td></tr></table></figure>
<h4 id="查看集群详细信息：">查看集群详细信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info dump </span><br></pre></td></tr></table></figure>
<h4 id="查看资源信息：">查看资源信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe &lt;资源&gt; &lt;名称&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：基本管理</title>
    <url>/2022/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Pod基本概念">Pod基本概念</h2>
<p>Pod是Kubernetes创建和管理的最小单元，一个Pod由一个容器 或多个容器组成，这些容器共享存储、网络。</p>
<p><img src="/images/3E268FAA2D524894BEC9CE7602E5ACDFclipboard.png" alt></p>
<p>Pod特点：</p>
<ul>
<li>
<p>一个Pod可以理解为是一个应用实例，提供服务</p>
</li>
<li>
<p>Pod中容器始终部署在一个Node上</p>
</li>
<li>
<p>Pod中容器共享网络、存储资源</p>
</li>
<li>
<p>Kubernetes直接管理Pod，而不是容器</p>
</li>
</ul>
<h2 id="Pod存在的意义">Pod存在的意义</h2>
<p>Pod主要用法：</p>
<ul>
<li>
<p>运行单个容器：最常见的用法，在这种情况下，可以将Pod看做是单个容器的抽象封装</p>
</li>
<li>
<p>运行多个容器：封装多个紧密耦合且需要共享资源的应用程序</p>
</li>
</ul>
<p>如果有这些需求，你可以运行多个容器：</p>
<ul>
<li>
<p>两个应用之间发生文件交互</p>
</li>
<li>
<p>两个应用需要通过127.0.0.1或者socket通信</p>
</li>
<li>
<p>两个应用需要发生频繁的调用</p>
</li>
</ul>
<h2 id="Pod资源共享实现机制">Pod资源共享实现机制</h2>
<p><img src="/images/615C60882D224E8DB8C6C12AAD1DB9CEclipboard.png" alt></p>
<p>共享网络：将业务容器网络加入到“负责网络的容器”实现网络共享</p>
<p>测试验证是否共享网络：</p>
<p>vim pod-net.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: <span class="built_in">test</span></span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-net.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod -c <span class="built_in">test</span> -- sh   <span class="comment">#进入tets容器验证是否能访问nginx</span></span><br><span class="line">wget 127.0.0.1:80 </span><br><span class="line"><span class="built_in">cat</span> index.html      </span><br></pre></td></tr></table></figure>
<p><img src="/images/83663818D7C24666AB6C087931A7E27Bclipboard.png" alt></p>
<p>共享存储：容器通过数据卷共享数据</p>
<p>测试验证是否共享存储：</p>
<p>vim pod-vol.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web2</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  - name: test2</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: <span class="built_in">log</span></span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-vol.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c test2 -- sh     <span class="comment">#进入test容器在/data目录下创建文件</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">touch</span> 1.txt</span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c web2 -- bash   <span class="comment">#进入web2容器/data目录下查看是否有1.txt</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h2 id="Pod管理命令">Pod管理命令</h2>
<p>创建Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod.yaml </span><br><span class="line">或者使用命令 kubectl run nginx --image=nginx </span><br></pre></td></tr></table></figure>
<p>查看Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods </span><br><span class="line">kubectl describe pod &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p>查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] </span><br><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] -f </span><br></pre></td></tr></table></figure>
<p>进入容器终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> &lt;pod名称&gt; [-c CONTAINER] -- bash </span><br></pre></td></tr></table></figure>
<p>删除Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/D3AF0D4278F7416FA89311678BF55FBDclipboard.png" alt></p>
<h2 id="重启策略-健康检查（应用自修复）">重启策略+健康检查（应用自修复）</h2>
<p><img src="/images/61383041DB4F45189A6A194539803642clipboard.png" alt></p>
<p>重启策略：</p>
<ul>
<li>
<p>Always：当容器终止退出后，总是重启容器，默认策略。</p>
</li>
<li>
<p>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</p>
</li>
<li>
<p>Never：当容器终止退出，从不重启容器</p>
</li>
</ul>
<p>健康检查有以下两种类型：</p>
<ul>
<li>
<p>livenessProbe（存活检查）：如果检查失败，将杀死容器，根据Pod 的restartPolicy来操	    作。</p>
</li>
<li>
<p>readinessProbe（就绪检查）：如果检查失败，Kubernetes会把 Pod从service endpoints中剔除。</p>
</li>
<li>
<p>startupProbe（启动检查）：</p>
</li>
</ul>
<p>支持以下三种检查方法：</p>
<ul>
<li>
<p>httpGet：发送HTTP请求，返回200-400范围状态码为成功。</p>
</li>
<li>
<p>exec：执行Shell命令返回状态码是0为成功。</p>
</li>
<li>
<p>tcpSocket：发起TCP Socket建立成功</p>
</li>
</ul>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></p>
<p>测试验证：</p>
<p>vim pod-check.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: liveness</span><br><span class="line">  name: pod-check</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30; <span class="built_in">rm</span> -rf /tmp/healthy; <span class="built_in">sleep</span> 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">    readinessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5     <span class="comment">##启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 5           <span class="comment">##以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-check.yaml</span><br><span class="line">kubectl expose pod pod-check --port 80 --target-port=80</span><br><span class="line">kubectl get pod -w           <span class="comment">#实时验证pod的重启次数是否增加</span></span><br><span class="line">kubectl get endpoints -w     <span class="comment">#实时验证pod是否被service剔除</span></span><br><span class="line">kubectl describe pod pod-check  <span class="comment">#查看pod的变化信息</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/619AB9E4410C495098F4F286EC63B2FBclipboard.png" alt></p>
<p><img src="/images/3D917C45F9F8485CBA8164C9A519E60Bclipboard.png" alt></p>
<p>示例：端口探测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: probe-demo</span><br><span class="line">  namespace: demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    readinessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注：livenessProbe与readinessProbe配置一样。">注：livenessProbe与readinessProbe配置一样。</h2>
<p>示例：执行Shell命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  <span class="built_in">exec</span>:</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="built_in">cat</span></span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure>
<h2 id="示例：HTTP请求">示例：HTTP请求</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure>
<h2 id="环境变量">环境变量</h2>
<p>变量值几种定义方式：</p>
<ul>
<li>
<p>自定义变量值</p>
</li>
<li>
<p>变量值从Pod属性获取</p>
</li>
<li>
<p>变量值从Secret、ConfigMap获取</p>
</li>
</ul>
<p>示例</p>
<p>vim pod-var.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-envars</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: <span class="built_in">test</span></span><br><span class="line">      image: busybox</span><br><span class="line">      <span class="built_in">command</span>: [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 36000&quot;</span>]</span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">      - name: MY_NODE_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: spec.nodeName</span><br><span class="line">      - name: MY_POD_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.name</span><br><span class="line">      - name: MY_POD_NAMESPACE</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.namespace</span><br><span class="line">      - name: MY_POD_IP</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: status.podIP</span><br><span class="line">      - name: ABC</span><br><span class="line">        value: <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-var.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-envars -- sh</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/4DA5F5128F174CD0BDF4FD1B2B0EF9C0clipboard.png" alt></p>
<h2 id="Init-Container">Init Container</h2>
<p>Init Container：顾名思义，用于初始化工作，执行完就结束，可以理解为一次性任务。</p>
<ul>
<li>
<p>支持大部分应用容器配置，但不支持健康检查</p>
</li>
<li>
<p>优先应用容器执行</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>环境检查：例如确保应用容器依赖的服务启动后再启动应用容器</p>
</li>
<li>
<p>初始化配置：例如给应用容器准备配置文件</p>
</li>
</ul>
<p>示例：</p>
<p>部署一个web网站，网站程序没有打到镜像中，而是希望从代码 仓库中动态拉取放到应用容器中。</p>
<p>vim pod-init.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: download</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - wget</span><br><span class="line">    - <span class="string">&quot;-O&quot;</span></span><br><span class="line">    - <span class="string">&quot;/opt/index.html&quot;</span></span><br><span class="line">    - http://www.ctnrs.com</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: <span class="string">&quot;/opt&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  volumes:</span><br><span class="line">  - name: wwwroot</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-init.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod init-demo </span><br><span class="line">kubectl <span class="built_in">exec</span> -it init-demo -- bash</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/3A5212D0E7FE4E829F051C6E3F7E4136clipboard.png" alt></p>
<p>因此，Pod中会有这几种类型的容器：</p>
<p>Infrastructure Container：基础容器</p>
<p>维护整个Pod网络空间</p>
<p>InitContainers：初始化容器</p>
<p>先于业务容器开始执行</p>
<p>Containers：业务容器</p>
<p>并行启动</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：调度</title>
    <url>/2022/06/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1%EF%BC%9A%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="创建一个Pod的工作流程">创建一个Pod的工作流程</h2>
<p>Kubernetes基于list-watch机制的控制器架构，实现组件间交 互的解耦。 其他组件监控自己负责的资源，当这些资源发生变化时，kubeapiserver会通知这些组件，这个过程类似于发布与订阅。</p>
<p><img src="/images/D8794DF48C0F4816BA54E7FA97CDBB36clipboard.png" alt></p>
<h2 id="Pod中影响调度的主要属性">Pod中影响调度的主要属性</h2>
<p><img src="/images/8AF33B3162AB4F3D882A6D2D180DC683clipboard.png" alt></p>
<h2 id="资源限制对Pod调度的影响">资源限制对Pod调度的影响</h2>
<p>容器资源限制：</p>
<ul>
<li>
<p>resources.limits.cpu</p>
</li>
<li>
<p>resources.limits.memory</p>
</li>
</ul>
<p>容器使用的最小资源需求，作为容器调度时资 源分配的依据：</p>
<ul>
<li>
<p>resources.requests.cpu</p>
</li>
<li>
<p>resources.requests.memory</p>
</li>
</ul>
<p>CPU单位：可以写m也可以写浮点数，例如0.5=500m，1=1000m</p>
<p><img src="/images/221BA88F1B514916BB8177EFC3777F22clipboard.png" alt></p>
<p>K8s会根据Request的值去查找有足够资源的Node来调度此Pod</p>
<p>vim pod-resources.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-resources</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:             <span class="comment">#容器最小资源配额</span></span><br><span class="line">        memory: <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;250m&quot;</span></span><br><span class="line">      limits:               <span class="comment">#容器最大资源上限</span></span><br><span class="line">        memory: <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-resources.yaml </span><br><span class="line">kubectl describe pod pod-resources </span><br><span class="line">kubectl describe nodes  k8s-node1</span><br><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<h2 id="nodeSelector-nodeAffinity">nodeSelector &amp; nodeAffinity</h2>
<p>nodeSelector：用于将Pod调度到匹配Label的Node上，如果没有匹配的标签会调度失败。</p>
<p>作用：</p>
<ul>
<li>
<p>约束Pod到特定的节点运行</p>
</li>
<li>
<p>完全匹配节点标签</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU</p>
</li>
</ul>
<p>示例：确保Pod分配到具有SSD硬盘的节点上</p>
<p>第一步：给节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br><span class="line">例如：kubectl label nodes k8s-node1 disktype=ssd</span><br><span class="line">验证：kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure>
<p><img src="/images/A8DD05B47B464360BC6A4C9562D81BBBclipboard.png" alt></p>
<p>第二步：添加nodeSelector字段到Pod配置中</p>
<p>vim pod-selector.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: <span class="string">&quot;ssd&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector.yaml </span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="/images/5B3E454BCE9B4228A079570CF0D7D7F0clipboard.png" alt></p>
<p>示例：使Pod分配到gpu是NVIDIA的节点上，k8s节点中并没有这个标签的节点</p>
<p>vim pod-selector2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector2</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: <span class="string">&quot;NVIDIA&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector2.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-selector2 </span><br></pre></td></tr></table></figure>
<p><img src="/images/825563AE4A8E4FB1A54BDE56BAB0FCA0clipboard.png" alt></p>
<p><img src="/images/AE756360AFBA4009A26073FD733BC33Aclipboard.png" alt></p>
<p>nodeAffinity：节点亲和性，与nodeSelector作用一样，但相比 更灵活，满足更多条件，诸如：</p>
<ul>
<li>
<p>匹配有更多的逻辑组合，不只是字符串的完全相等</p>
</li>
<li>
<p>调度分为软策略和硬策略，而不是硬性要求</p>
</li>
<li>
<p>硬（required）：必须满足</p>
</li>
<li>
<p>软（preferred）：尝试满足，但不保证</p>
</li>
</ul>
<p>操作符：In、NotIn、Exists、DoesNotExist、Gt、Lt</p>
<p>示例：在pod满足硬性标签要求的前提下，如果没有满足其他的标签，则在满足硬性标签要求的机器上随机调度分配一台</p>
<p>vim pod-affinity.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-node-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: gpu</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - nvidia-tesla</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: group</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - ai</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-affinity.yaml</span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-node-affinity </span><br></pre></td></tr></table></figure>
<p><img src="/images/095D6E3DA6D04C2192B2F95B272255D5clipboard.png" alt></p>
<p>验证：</p>
<p>1.如果两个节点都满足硬性标签要求，其中一个节点也满足软性标签要求，那么会优先分配到这个节点。</p>
<p>2.如果两个节点都满足硬性标签要求，都没有满足软性标签要求，那么会随机调度到其中的一个节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给节点添加标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt; </span><br><span class="line">例如：kubectl label node 192.168.1.205 mem=large</span><br><span class="line"><span class="comment">#给节点删除标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;-</span><br><span class="line">例如：kubectl label node 192.168.1.205 mem-</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Taint（污点）与Tolerations（污点容忍）">Taint（污点）与Tolerations（污点容忍）</h2>
<p>Taints：避免Pod调度到特定Node上</p>
<p>Tolerations：允许Pod调度到持有Taints的Node上</p>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>基于Taint的驱逐</p>
</li>
</ul>
<p>第一步：给节点添加污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl taint node [node] key=value:[effect] </span><br><span class="line">例如：kubectl taint node k8s-node1 gpu=<span class="built_in">yes</span>:NoSchedule </span><br><span class="line">验证：kubectl describe node k8s-node1 |grep Taint</span><br></pre></td></tr></table></figure>
<p>其中[effect] 可取值：</p>
<ul>
<li>
<p>NoSchedule ：一定不能被调度</p>
</li>
<li>
<p>PreferNoSchedule：尽量不要调度，非必须配置容忍</p>
</li>
<li>
<p>NoExecute：不仅不会调度，还会驱逐Node上已有的Pod</p>
</li>
</ul>
<p>第二步：添加污点容忍（tolrations）字段到Pod配置中</p>
<p><img src="/images/6D0B55F924AC4E66A1BBBEEB2457C77Cclipboard.png" alt></p>
<p>去掉污点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key:[effect]-</span><br></pre></td></tr></table></figure>
<p>示例一</p>
<p>1.给node节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes k8s-node1 gpu=iniaid</span><br><span class="line">kubectl label nodes k8s-node2 disktype=ssd</span><br><span class="line">kubectl get nodes --show-labels </span><br><span class="line">kubectl taint node |grep Taint</span><br></pre></td></tr></table></figure>
<p>2.给node1节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node1 gpu=iniaid:NoSchedule</span><br></pre></td></tr></table></figure>
<p>3.新建pod2.yaml文件并启动pod</p>
<p>vim pod2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>4.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod2.yaml </span><br><span class="line">kubectl get pod -o wide  <span class="comment">#观察pod2是否被调度到node2节点上</span></span><br></pre></td></tr></table></figure>
<p>示例二</p>
<p>1.基于示例一，给node2节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node2 disktype=ssd:NoSchedule</span><br></pre></td></tr></table></figure>
<p>2.新建pod3.yaml文件并启动pod</p>
<p>vim pod3.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod3</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>3.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod3.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#查看pod3是否处于pending状态</span></span><br><span class="line">kubectl describe pod pod3    <span class="comment">#查看pod3的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/5E8FF7CD88DC4C12AF574509137E2137clipboard.png" alt></p>
<h2 id="上面的意思是默认计划程序0-3个节点可用：1个节点有污点-disktype-ssd-，pod不能容忍，1个节点有污点-gpu-iniaid-，pod不能容忍，1个节点有污点-node-role-kubernetes-io-主。">上面的意思是默认计划程序0/3个节点可用：1个节点有污点{disktype:ssd}，pod不能容忍，1个节点有污点{gpu:iniaid}，pod不能容忍，1个节点有污点{node}-role.kubernetes.io/主。</h2>
<h2 id="示例三">示例三</h2>
<p>1.基于示例二，添加污点容忍使pod能够分配到node1节点上</p>
<p>vim pod4.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod4</span><br><span class="line">spec:</span><br><span class="line">  tolerations:                  <span class="comment">#意思是分配到标签gpu=iniaid的这个节点上</span></span><br><span class="line">  - key: <span class="string">&quot;gpu&quot;</span>                   </span><br><span class="line">    operator: <span class="string">&quot;Equal&quot;</span>           <span class="comment">#操作符等于的意思</span></span><br><span class="line">    value: <span class="string">&quot;iniaid&quot;</span></span><br><span class="line">    effect: <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="加上effect-NoSchedule-的意思：更精确一点，如果不加的话，比如两个节点都有gpu-iniaid这个标签，但它们的effect的调度策略不同，那么pod可能会分配到这两个节点上。">加上effect: &quot;NoSchedule&quot;的意思：更精确一点，如果不加的话，比如两个节点都有gpu=iniaid这个标签，但它们的effect的调度策略不同，那么pod可能会分配到这两个节点上。</h2>
<h2 id="2-验证">2.验证</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod4.yaml </span><br><span class="line">kubectl get pod  -o wide   <span class="comment">#验证是否被分配到node1节点上</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/982EB5703C1E487E9146B059C6435868clipboard.png" alt></p>
<h2 id="最后去掉污点">最后去掉污点</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe nodes |grep Taint   <span class="comment">#查看当前有污点的节点</span></span><br><span class="line">kubectl taint node k8s-nod2 disktype-    <span class="comment">#去掉node1节点的污点</span></span><br><span class="line">kubectl taint node k8s-node2 disktype-   <span class="comment">#去掉node2节点的污点</span></span><br><span class="line">kubectl describe nodes |grep Taint      <span class="comment">#验证是否去掉了污点</span></span><br></pre></td></tr></table></figure>
<h2 id="验证pod3是否被调度成功">验证pod3是否被调度成功</h2>
<p><img src="/images/4978D9F6F11F4C1987D9EC08C3E68324clipboard.png" alt></p>
<h2 id="nodeName">nodeName</h2>
<p>nodeName：指定节点名称，用于将Pod调度到指定的Node上，不经过调度器</p>
<p>示例：将pod指定到有污点的节点上</p>
<p>vim pod5.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod5</span><br><span class="line">spec:</span><br><span class="line">  nodeName: k8s-node2</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod5.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#可以看到pod成功运行，因为它不经过调度器</span></span><br></pre></td></tr></table></figure>
<p>适用于调度器故障的时候，可以手动指定分配pod到某个节点上，很少使用。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>资源编排（YAML）</title>
    <url>/2022/06/13/%E8%B5%84%E6%BA%90%E7%BC%96%E6%8E%92%EF%BC%88YAML%EF%BC%89/</url>
    <content><![CDATA[<h2 id="YAML文件格式说明">YAML文件格式说明</h2>
<p>K8s是一个容器编排引擎，使用YAML文件编排要部署应用，因此在学习之前，应先了解YAML语法格式：</p>
<ul>
<li>
<p>缩进表示层级关系</p>
</li>
<li>
<p>不支持制表符“tab”缩进，使用空格缩进</p>
</li>
<li>
<p>通常开头缩进 2 个空格</p>
</li>
<li>
<p>字符后缩进 1 个空格，如冒号、逗号等</p>
</li>
<li>
<p>“—” 表示YAML格式，一个文件的开始</p>
</li>
<li>
<p>“#”注释</p>
</li>
</ul>
<h2 id="YAML文件创建资源对象">YAML文件创建资源对象</h2>
<p><img src="/images/DDD11D0D0D92486CBFCC20771E6BA98Dclipboard.png" alt></p>
<p>等同于：kubectl create deployment web --image=lizhenliang/java-demo -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: lizhenliang/java-demo</span><br></pre></td></tr></table></figure>
<p><img src="/images/5F75CF2C8465417682F5B254CD102040clipboard.png" alt></p>
<p>等同于：kubectl expose deployment web --port=80 --target-port=8080 --type=NodePort -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: web</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure>
<p>将你需要创建的资源描述到YAML文件中。</p>
<p>部署：kubectl apply -f xxx.yaml</p>
<p>卸载：kubectl delete -f xxx.yaml</p>
<p><img src="/images/049922DAA12B45238787D8DCE47434FBclipboard.png" alt></p>
<h2 id></h2>
<h2 id="资源字段太多，记不住怎么办">资源字段太多，记不住怎么办</h2>
<p>用create命令生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx:1.16 -o yaml --dry-run=client &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>用get命令导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment nginx -o yaml &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>Pod容器的字段拼写忘记了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain pods.spec.containers </span><br><span class="line">kubectl explain deployment</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像的制作CMD与ENTRYPOINT区别</title>
    <url>/2022/05/24/%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%B6%E4%BD%9CCMD%E4%B8%8EENTRYPOINT%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.构建镜像时必须指定一个CMD 或者ENTRYPOINT 去夯住进程，不让它退出，放在容器前台执行，否则容器就退出了。</p>
<p>2.CMD exec 形式变量传参需要指定（“sh”,“-c”,“/usr/bin/run.sh $abc”）</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD [“sh”,“-c”,“/usr/bin/run.sh $abc”]</p>
<p>3.CMD shell形式直接使用变量传参</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD <a href="http://run.sh">run.sh</a> $abc</p>
<p>4.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> liuzhe</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的CMD命令</p>
<p>5.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> wangwu</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的ENTRYPOINT命令需要指定 --entrypoint参数</p>
<p>6.当CMD和ENTRYPOINT配合使用时，CMD的值会作为ENTRYPOINT 的默认参数</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>ENTRYPOINT [“<a href="http://run.sh">run.sh</a>”]     #ENTRYPOINT执行 可执行文件  必须使用exec的形式</p>
<p>CMD [“hello”,“libai”]      #CMD的值为ENTRYPOINT传参</p>
<p>#####<a href="http://run.sh#######">run.sh#######</a></p>
<p>#!/bin/bash</p>
<p>echo $@</p>
<p>sleep 70000</p>
<p>最终执行的命令就是</p>
<p>/usr/bin/run.sh hello libai</p>
<p>docker run -d test hello liuzhe 也可以通过命令行的形式覆盖CMD命令的值</p>
<p>小结：</p>
<ol>
<li>
<p>CMD和ENTRYPOINT指令都可以用来定义运行容器时所使用的默认命令</p>
</li>
<li>
<p>Dockerfile至少指定一个CMD或ENTRYPOINT</p>
</li>
<li>
<p>CMD可以用作ENTRYPOINT默认参数，或者用作容器的默认命令</p>
</li>
<li>
<p>docker run指定<command>时，将会覆盖CMD的值</p>
</li>
<li>
<p>如果是可执行文件，希望运行时传参，应该使用ENTRYPOINT</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>

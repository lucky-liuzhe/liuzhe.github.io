<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Harbor部署</title>
    <url>/2022/05/25/harbor%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>Harbor 概述</p>
<p>Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展， 从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及 审计日志等，足以满足基本企业需求。</p>
<p>官方：<a href="https://goharbor.io/">https://goharbor.io/</a></p>
<p>Github：<a href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>Harbor 部署先决条件</p>
<p>服务器硬件配置：</p>
<p>最低要求：CPU2核/内存4G/硬盘40GB</p>
<p>推荐：CPU4核/内存8G/硬盘160GB</p>
<p>软件：</p>
<p>Docker CE 17.06版本+</p>
<p>Docker Compose 1.18版本+</p>
<p>Harbor安装有2种方式：</p>
<p>在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小</p>
<p>离线安装：安装包包含部署的相关镜像，因此安装包比较大</p>
<p>Harbor 部署HTTP</p>
<p>1、先安装Docker和Docker Compose</p>
<p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<p>2、部署Harbor HTTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar zxvf harbor-offline-installer-v2.0.0.tgz </span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: reg.azhe.com </span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>3、访问harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://reg.azhe.com/</span><br></pre></td></tr></table></figure>
<p><img src="/images/65FF30622A314D5391BD5ACBBEC52776clipboard.png" alt></p>
<p>Harbor 基本使用</p>
<p>1、配置http镜像仓库可信任（默认是https访问的，上面配置的是http，这里需要配置可信任)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置http镜像仓库可信任</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;reg.azhe.com&quot;</span>]&#125; </span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看是否有harbor容器退出，重新停止再拉起</span></span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>2.配置本地hosts文件解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>3.登录harbbor,打标签，上传，下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker tag mysql:5.7 reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker push reg.azhe.com/library/mysql:5.7</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p><img src="/images/158D447BE1A84A4C96A9CC38A8FF762Dclipboard.png" alt></p>
<p>Harbor 部署HTTPS</p>
<p>1、生成SSL证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ssl</span><br><span class="line"><span class="built_in">cd</span> ssl</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">ca-config.json  ca-key.pem  cfssl.sh               reg.azhe.com-key.pem</span><br><span class="line">ca.csr          ca.pem      reg.azhe.com.csr       reg.azhe.com.pem</span><br><span class="line">ca-csr.json     certs.sh    reg.azhe.com-csr.json</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://cfssl.sh">cfssl.sh</a> (证书生成工具）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://certs.sh">certs.sh</a>(证书生成脚本）</p>
<p>#注意里面的域名修改为自己的harbor域名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; reg.azhe.com-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;reg.azhe.com&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes reg.azhe.com-csr.json | cfssljson -bare reg.azhe.com </span><br></pre></td></tr></table></figure>
<p>2、Harbor启用HTTPS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi harbor.yml</span><br><span class="line">https:</span><br><span class="line">  port: 443</span><br><span class="line">   certificate: /root/ssl/reg.azhe.com.pem     <span class="comment">#指定你生成的数字证书</span></span><br><span class="line">   private_key: /root/ssl/reg.azhe.com-key.pem   <span class="comment">#指定key</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>3、重新配置并部署Harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prepare </span><br><span class="line">docker-compose down </span><br><span class="line">docker-compose up –d</span><br></pre></td></tr></table></figure>
<p>4、修改Docker启动文件添加“–insecure-registry <a href="http://reg.azhe.com">reg.azhe.com</a>”并配置hosts文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry reg.azhe.com</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.0.11 reg.azhe.com</span><br></pre></td></tr></table></figure>
<p>5、验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker /images</span><br><span class="line">docker pull reg.azhe.com/library/mysql:5.7</span><br></pre></td></tr></table></figure>
<p>以上harbor部署https方式的第4步骤，如果配置完成后，在docker主机登录harbor报证书错误，那么可以通过以下方式解决或参考链接：</p>
<p>4.将数字证书复制到Docker主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp reg.azhe.com.pem root@192.168.0.13:~   <span class="comment">#拷贝到要登录harbor的docker客户端</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/docker/certs.d/reg.azhe.com</span><br><span class="line"><span class="built_in">cp</span> reg.azhe.com.pem /etc/docker/certs.d/reg.azhe.com/reg.azhe.com.crt</span><br></pre></td></tr></table></figure>
<p>参考链接</p>
<p><a href="https://blog.csdn.net/chenglang0914/article/details/100833054">https://blog.csdn.net/chenglang0914/article/details/100833054</a></p>
<p>Harbor 主从复制</p>
<p><img src="/images/B77A284AA7994A2894263F4F287452E8clipboard.png" alt></p>
<p>主备模式</p>
<p>1.准备备机harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line">tar -zxf harbor-offline-installer-v2.0.0.tgz</span><br><span class="line"><span class="built_in">cd</span> harbor </span><br><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml </span><br><span class="line"></span><br><span class="line">vi harbor.yml </span><br><span class="line">hostname: 192.168.0.12</span><br><span class="line"><span class="comment">#https: # 先注释https相关配置 </span></span><br><span class="line">harbor_admin_password: Harbor12345 </span><br><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>2.在主harbor页面配置主从复制和规则</p>
<p><img src="/images/2A099C79ECDB4C83B3D5917E0BDA3BE6clipboard.png" alt></p>
<p><img src="/images/2726A20B44774F2EABFB8A0F45DDC380clipboard.png" alt></p>
<p>3.客户端docker主机上传镜像到主harbor并验证是否复制到从harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login reg.azhe.com</span><br><span class="line">Username: admin</span><br><span class="line">Password: Harbor12345</span><br><span class="line"></span><br><span class="line">docker tag centos:7 reg.azhe.com/library/centos:7</span><br><span class="line">docker push reg.azhe.com/library/centos:7</span><br></pre></td></tr></table></figure>
<p><img src="/images/F29DE1853ED34C21961D7A4A2EEB9CADclipboard.png" alt></p>
<p><img src="/images/FF5C2BF9C43248F4AE5521F5F200F61Cclipboard.png" alt></p>
<p><img src="/images/71319B66EA1E4E36A28CDFA7BE80681Eclipboard.png" alt></p>
<p>Harbor 运维维护</p>
<p><img src="/images/4CBC3EA772514E54B38302F5409C461Aclipboard.png" alt></p>
<p>容器数据持久化目录：/data</p>
<p>日志文件目录：/var/log/harbor</p>
<p>PG数据库做好定期备份，里面存放用户数据文件。</p>
<p>主从复制，主harbor挂掉，启用备harbor，需要把pg数据导入到备harbor。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ingress最佳方式对外暴露应用</title>
    <url>/2022/07/10/ingress%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Ingress是什么">Ingress是什么</h2>
<p>NodePort存在的不足：</p>
<ul>
<li>
<p>一个端口只能一个服务使用，端口需提前规划</p>
</li>
<li>
<p>只支持4层负载均衡</p>
</li>
</ul>
<p>Ingress：Ingress公开了从集群外部到集群内服务的HTTP和HTTPS路由的规则集合，而具体实现流量路 由则是由Ingress Controller负责。</p>
<ul>
<li>
<p>Ingress：K8s中的一个抽象资源，给管理员 提供一个暴露应用的入口定义方法</p>
</li>
<li>
<p>Ingress Controller：根据Ingress生成具体 的路由规则，并对Pod负载均衡器</p>
</li>
</ul>
<p><img src="/images/A2C7CDD3D8F548A98C5BF3FF5833B996clipboard.png" alt></p>
<h2 id="Ingress-Controller">Ingress Controller</h2>
<p>Ingress Controller有很多实现，我们这里采用官方维护的Nginx控制器。</p>
<p>项目地址：<a href="https://github.com/kubernetes/ingress-nginx">https://github.com/kubernetes/ingress-nginx</a></p>
<p>部署：kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx0.30.0/deploy/static/mandatory.yaml">https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx0.30.0/deploy/static/mandatory.yaml</a></p>
<p>注意事项：</p>
<ul>
<li>
<p>镜像地址修改成国内的：lizhenliang/nginx-ingress-controller:0.30.0</p>
</li>
<li>
<p>将Ingress Controller暴露，一般使用宿主机网络（hostNetwork: true）或者使用NodePort</p>
</li>
</ul>
<p>其他控制器：<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/</a></p>
<h2 id="Ingress">Ingress</h2>
<p>部署deployment与serivce</p>
<p>vim web1-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web1</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web1</span><br><span class="line">        image: nginx:1.15</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web1</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web1-deploy-svc.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl 10.99.227.165</span><br></pre></td></tr></table></figure>
<p>部署ingress（基于域名方式访问）</p>
<p>vim ingress-web1.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web1</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web1.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://xn--web1-z03g362j2w5b9jdn63a.ctnrs.com">浏览器访问web1.ctnrs.com</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-web1.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>测试：本地电脑绑定hosts记录对应ingress里面配置的域名</p>
<p>例： &lt;Ingress Controller Pod所在Node IP&gt; <a href="http://foo.bar.com">foo.bar.com</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n ingress-nginx -o wide</span><br></pre></td></tr></table></figure>
<h2 id="Ingress：基于URI路由多个服务">Ingress：基于URI路由多个服务</h2>
<p>vim web2-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web2</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web2 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.15</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web2</span><br><span class="line">  name: web2</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web2 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim web22-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web22</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web22</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web22 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web22</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web22</span><br><span class="line">  name: web22</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web22 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim ingress-web2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web2</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /<span class="variable">$2</span></span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">      rewrite ^/css/(.*)$ /bar/css/<span class="variable">$1</span> redirect;</span><br><span class="line">      rewrite ^/images/(.*)$ /bar/images/<span class="variable">$1</span> redirect;</span><br><span class="line">      rewrite ^/js/(.*)$ /bar/js/<span class="variable">$1</span> redirect;</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web2.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /foo                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web2            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line">      - path: /bar(/|$)(.*)                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web22            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8080          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web2-deploy-svc.yaml </span><br><span class="line">kubectl apply -f web22-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web2.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl get svc</span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://web2.ctnrs.com/bar</span><br><span class="line">http://web2.ctnrs.com/foo</span><br></pre></td></tr></table></figure>
<h2 id="Ingress-：基于名称的虚拟主机">Ingress ：基于名称的虚拟主机</h2>
<p><img src="/images/F43B7E2488D24867918ACC44A42437CEclipboard.png" alt></p>
<p>vim web3-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web3</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web-tomcat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web-tomcat <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: java-demo</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web-tomcat</span><br><span class="line">  name: web3</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 88 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web-tomcat <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim ingress-web3.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web3</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web3-1.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 80          <span class="comment">#ClusterIP的端口</span></span><br><span class="line">  - host: web3-2.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web3            <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 88          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web3-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web3.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">web3-1.ctnrs.com</span><br><span class="line">web3-2.ctnrs.com </span><br></pre></td></tr></table></figure>
<h2 id="Ingress：HTTPS">Ingress：HTTPS</h2>
<p>配置HTTPS步骤：</p>
<p>1、准备域名证书文件（来自：openssl/cfssl工具自签或者权威机构颁发）</p>
<p>vim <a href="http://cfssl.sh">cfssl.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>
<p>vim <a href="http://certs.sh">certs.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; web4.ctnrs.com-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;web4.ctnrs.com&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes web4.ctnrs.com-csr.json | cfssljson -bare web4.ctnrs.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash cfssl.sh</span><br><span class="line">bash certs.sh</span><br></pre></td></tr></table></figure>
<p>2、将证书文件保存到Secret</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls web4-ctnrs-com --cert=ssl/web4.ctnrs.com.pem --key=ssl/web4.ctnrs.com-key.pem</span><br><span class="line">kubectl get secrets </span><br></pre></td></tr></table></figure>
<p>3、Ingress规则配置tls</p>
<p>vim ingress-web4-https.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web4</span><br><span class="line">spec:</span><br><span class="line">  tls:</span><br><span class="line">  - hosts:</span><br><span class="line">    - web4.ctnrs.com                 <span class="comment">#自签证书对应的域名</span></span><br><span class="line">    secretName: web4-ctnrs-com       <span class="comment">#Secret的名字</span></span><br><span class="line">  rules:</span><br><span class="line">  - host: web4.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-web4-https.yaml </span><br><span class="line">kubectl get ingress</span><br></pre></td></tr></table></figure>
<p>配置本地hosts文件解析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.12      web1.ctnrs.com  web4.ctnrs.com  </span><br><span class="line">192.168.1.13      web1.ctnrs.com  web4.ctnrs.com  </span><br></pre></td></tr></table></figure>
<p>访问</p>
<p><img src="/images/5BA66364BB194B94A5D1992F439DB35Aclipboard.png" alt></p>
<h2 id="Ingress：个性化配置">Ingress：个性化配置</h2>
<p>示例1：设置代理超时参数</p>
<p>vim ingress-annotations.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: annotations</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: annotations.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-annotations.yaml </span><br><span class="line">kubectl get ingress</span><br><span class="line">kubectl get pod -n ingress-nginx </span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-ingress-controller-qj4vg bash -n ingress-nginx </span><br><span class="line"><span class="variable">$vi</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>查看是否有代理的配置</p>
<p><img src="/images/7342077EDF3E4812AED83A5730609A01clipboard.png" alt></p>
<p>示例2：设置客户端上传文件大小</p>
<p>vim ingress-annotations.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: annotations</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/ingress.class: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: <span class="string">&quot;600&quot;</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-body-size: <span class="string">&quot;10m&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: annotations.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web1</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f ingress-annotations.yaml </span><br><span class="line">kubectl get pod -n ingress-nginx </span><br><span class="line">kubectl <span class="built_in">exec</span> -it nginx-ingress-controller-qj4vg bash -n ingress-nginx </span><br><span class="line"><span class="variable">$vi</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>查看annotations.ctnrs.com域名下有没有相关的配置</p>
<p><img src="/images/2DF62D4954594D6DB5667A0BD8C86C6Eclipboard.png" alt></p>
<p>示例3：重定向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/rewrite-target: https://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>示例4：自定义规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&#x27;(Android|iPhone)&#x27;</span>) &#123;</span><br><span class="line">    rewrite ^/(.*) http://m.baidu.com <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>vim web5-deploy-svc.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web5</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web5</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web5 <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web5-java-demo</span><br><span class="line">        image: lizhenliang/java-demo</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web5</span><br><span class="line">  name: web5</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 8888 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 8080 <span class="comment"># 容器端口</span></span><br><span class="line">   <span class="comment"># nodePort: 30009    #nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web5 <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="vim-ingress-web5-yaml">vim ingress-web5.yaml</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: web5</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/server-snippet: |</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&#x27;(Android|iPhone)&#x27;</span>) &#123;</span><br><span class="line">        rewrite ^/(.*) http://m.baidu.com <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: web5.ctnrs.com        <span class="comment">#域名</span></span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /                  <span class="comment">#类似nginx配置文件的location /访问路径</span></span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: web5        <span class="comment">#service的名字</span></span><br><span class="line">            port:</span><br><span class="line">              number: 8888          <span class="comment">#ClusterIP的端口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web5-deploy-svc.yaml </span><br><span class="line">kubectl apply -f ingress-web5.yaml </span><br><span class="line">kubectl get ingress</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>电脑端访问：<a href="http://web5.ctnrs.com/">http://web5.ctnrs.com/</a></p>
<p><img src="/images/04BC8BD141DD47EF9D3744B923B3C53Aclipboard.png" alt></p>
<p>使用电脑火狐浏览器模仿手机端访问跳转到百度页面</p>
<p><img src="/images/EC681CFC0F3C4BF7822277C1AFDB0999clipboard.png" alt></p>
<p>注：上面这些配置都是针对Nginx Server块生效</p>
<p>更多使用方法：<a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md">https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md</a></p>
<h2 id="Ingress-Controller-2">Ingress Controller</h2>
<p>Ingress Contronler怎么工作的？</p>
<p>Ingress Contronler通过与 Kubernetes API 交互，动态的去感知集群中 Ingress 规则变化，然后读取它， 按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段 Nginx 配置，应用到管理的 Nginx服务，然后热加载生效。 以此来达到Nginx负载均衡器配置及动态更新的问题。</p>
<p>流程包流程：客户端 -&gt;Ingress Controller（nginx） -&gt; 分布在各节点Pod</p>
<h2 id="Ingress-Controller高可用方案">Ingress Controller高可用方案</h2>
<p>一般Ingress Controller会以DaemonSet+nodeSelector部署到几台特定 Node，然后将这几台挂载到公网负载均衡器对外提供服务。</p>
<p><img src="/images/9267ADA4F67F4FE9BDD1C7371BEA7534clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA项目镜像构建：Tomcat</title>
    <url>/2022/05/23/java%E9%A1%B9%E7%9B%AE%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>JAVA项目镜像构建：Tomcat</p>
<p>tomcat目录文件：1.apache-tomcat-8.5.43.tar.gz  2.Dockerfile   3.Dockerfile2  4.ROOT.war</p>
<p>Dockerfile（环境镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dockerfile2 (基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM tomcat:v1</span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/tomcat/webapps/*</span><br><span class="line">COPY ROOT.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> tomcat/</span><br><span class="line">docker build -t tomcat:v1 .</span><br><span class="line">docker build -t tomcat:v2 -f Dockerfile2 .</span><br><span class="line">docker run -d -p 8888:8080 --name tomcat tomcat:v2</span><br></pre></td></tr></table></figure>
<p>访问tomcat 8888端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.0.11:8888/</span><br></pre></td></tr></table></figure>
<p>JAVA微服务镜像构建：Jar</p>
<p>java目录文件:1.Dockerfile  2.hello.jar</p>
<p>Dockerfile(基于环境镜像打包的项目镜像）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM java:8-jdk-alpine</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">ENV JAVA_OPTS=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> -Dfile.encoding=UTF8 -Duser.timezone=GMT+08&quot;</span></span><br><span class="line">RUN sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="line">    apk add -U tzdata &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">COPY hello.jar /</span><br><span class="line">EXPOSE 8888</span><br><span class="line">CMD [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java -jar <span class="variable">$JAVA_OPTS</span> /hello.jar&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写Dockerfile最佳实践</p>
<p>减少镜像层：一次RUN指令形成新的一层，尽量Shell命令都写在一行，减少镜像层。</p>
<p>优化镜像大小：一次RUN形成新的一层，如果没有在同一层删除，无论文件是否最后删除， 都会带到下一层，所以要在每一层清理对应的残留数据，减小镜像大小。</p>
<p>减少网络传输时间：例如软件包、mvn仓库等</p>
<p>多阶段构建：代码编译、部署在一个Dockerfile完成，只会保留部署阶段产生数据。</p>
<p>选择最小的基础镜像：例如alpine</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s安全控制</title>
    <url>/2022/07/14/k8s%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Kubernetes-安全框架">Kubernetes 安全框架</h2>
<p>K8S安全控制框架主要由下面3个阶段进行控制，每一个阶段都 支持插件方式，通过API Server配置来启用插件。</p>
<ol>
<li>
<p>Authentication（鉴权）</p>
</li>
<li>
<p>Authorization（授权）</p>
</li>
<li>
<p>Admission Control（准入控制）</p>
</li>
</ol>
<p>客户端要想访问K8s集群API Server，一般需要证书、Token或 者用户名+密码；如果Pod访问，需要ServiceAccount</p>
<p><img src="/images/BA1BA2242FE74CF5AF4D103D2CE779B6clipboard.png" alt></p>
<h2 id="鉴权（Authentication）">鉴权（Authentication）</h2>
<p>三种客户端身份认证：</p>
<ul>
<li>
<p>HTTPS 证书认证：基于CA证书签名的数字证书认证</p>
</li>
<li>
<p>HTTP Token认证：通过一个Token来识别用户</p>
</li>
<li>
<p>HTTP Base认证：用户名+密码的方式认证</p>
</li>
</ul>
<h2 id="授权（Authorization）">授权（Authorization）</h2>
<p>RBAC（Role-Based Access Control，基于角色的访问控制）：负责完成授权（Authorization）工作。</p>
<p>RBAC根据API请求属性，决定允许还是拒绝。</p>
<p>比较常见的授权维度：</p>
<ul>
<li>
<p>user：用户名</p>
</li>
<li>
<p>group：用户分组</p>
</li>
<li>
<p>资源，例如pod、deployment</p>
</li>
<li>
<p>资源操作方法：get，list，create，update，patch，watch，delete</p>
</li>
<li>
<p>命名空间</p>
</li>
<li>
<p>API组</p>
</li>
</ul>
<h2 id="准入控制（Admission-Control）">准入控制（Admission Control）</h2>
<p>Adminssion Control实际上是一个准入控制器插件列表，发送到API Server 的请求都需要经过这个列表中的每个准入控制器插件的检查，检查不通过， 则拒绝请求。</p>
<h2 id="基于角色的权限访问控制：RBAC">基于角色的权限访问控制：RBAC</h2>
<p>RBAC（Role-Based Access Control，基于角色的访问控 制），允许通过Kubernetes API动态配置策略。</p>
<p>角色</p>
<ul>
<li>
<p>Role：授权特定命名空间的访问权限</p>
</li>
<li>
<p>ClusterRole：授权所有命名空间的访问权限</p>
</li>
</ul>
<p>角色绑定</p>
<ul>
<li>
<p>RoleBinding：将角色绑定到主体（即subject）</p>
</li>
<li>
<p>ClusterRoleBinding：将集群角色绑定到主体</p>
</li>
</ul>
<p>主体（subject）</p>
<ul>
<li>
<p>User：用户</p>
</li>
<li>
<p>Group：用户组</p>
</li>
<li>
<p>ServiceAccount：服务账号</p>
</li>
</ul>
<p><img src="/images/00B32E081B29474B860179448537BA37clipboard.png" alt></p>
<h2 id="案例：为指定用户授权访问不同命名空间权限">案例：为指定用户授权访问不同命名空间权限</h2>
<p>示例：为azhe用户授权default命名空间Pod读取权限</p>
<ol>
<li>用K8S CA签发客户端证书</li>
</ol>
<p>安装cfssl工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim cfssl.sh</span></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl*</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash cfssl.sh</span></span><br></pre></td></tr></table></figure>
<p>生成证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim cert.sh </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; azhe-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;azhe&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=/etc/kubernetes/pki/ca.crt -ca-key=/etc/kubernetes/pki/ca.key -config=ca-config.json -profile=kubernetes azhe-csr.json | cfssljson -bare azhe</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash cert.sh </span></span><br></pre></td></tr></table></figure>
<p>数字证书和key</p>
<p><img src="/images/0A9228A856504E6EB4AF08FF1961AEE3clipboard.png" alt></p>
<ol start="2">
<li>生成kubeconfig授权文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成kubeconfig授权文件：</span></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">--certificate-authority=/etc/kubernetes/pki/ca.crt \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--server=https://192.168.1.11:6443 \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置客户端认证</span></span><br><span class="line">kubectl config set-credentials azhe \</span><br><span class="line">--client-key=azhe-key.pem \</span><br><span class="line">--client-certificate=azhe.pem \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认上下文</span></span><br><span class="line">kubectl config set-context kubernetes \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=azhe \</span><br><span class="line">--kubeconfig=azhe.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前使用配置</span></span><br><span class="line">kubectl config use-context kubernetes --kubeconfig=azhe.kubeconfig</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建RBAC权限策略</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim rbac.yaml</span></span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: azhe</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rbac.yaml </span><br><span class="line"><span class="comment">#指定kubeconfig文件测试：</span></span><br><span class="line">kubectl get pod --kubeconfig=./azhe.kubeconfig </span><br></pre></td></tr></table></figure>
<p>查看deployment和service（修改rbac文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim rbac.yaml </span></span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [<span class="string">&quot;&quot;</span>,<span class="string">&quot;apps&quot;</span>]</span><br><span class="line">  resources: [<span class="string">&quot;pods&quot;</span>,<span class="string">&quot;deployments&quot;</span>,<span class="string">&quot;services&quot;</span>]  <span class="comment">#资源类型权限</span></span><br><span class="line">  verbs: [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: azhe</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rbac.yaml </span><br><span class="line">kubectl get deployments.apps --kubeconfig=./azhe.kubeconfig </span><br><span class="line">kubectl get services --kubeconfig=./azhe.kubeconfig </span><br><span class="line">kubectl api-versions <span class="comment">#查看k8s资源组</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/861B72416FB74D8892A146DE804610C7clipboard.png" alt></p>
<p>当客户端使用kubectl时，它会向APIserver发送请求，它会根据你客户端的身份，比如数字认证方式，它会提取证书里面cn字段，cn字段作为你的用户名，会先验证你的身份是不是可信任的，或者证书是不是ca颁发的，验证没问题后会检查有没有给你授权，还有准入控制器插件列表检查，如果通过后你查看就会返回成功。</p>
<p>客户端要想访问k8s集群，需要拿着kubeconfig授权文件去访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拷贝kubeconfig授权文件到客户端</span></span><br><span class="line">scp azhe.kubeconfig root@192.168.0.13:~</span><br><span class="line"><span class="comment">#客户端指定授权文件访问</span></span><br><span class="line">kubectl get services --kubeconfig=azhe.kubeconfig </span><br><span class="line"><span class="comment">#如果不想指定授权文件访问，可以将授权文件移动到kube目录下，这时就不需要指定了</span></span><br><span class="line"><span class="built_in">mkdir</span> .kube/</span><br><span class="line"><span class="built_in">mv</span> azhe.kubeconfig  .kube/config</span><br></pre></td></tr></table></figure>
<p>ServiceAccount：服务账号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get sa -n kubernetes-dashboard</span><br><span class="line">kubectl describe sa -n kubernetes-dashboard </span><br><span class="line">kubectl get secrets -n kubernetes-dashboard </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ui——&gt;token（保存至secret中）——&gt;apiserver——&gt;rbac（ServiceAccount）</p>
<p>User和Group是针对用户授权访问APIserver的，ServiceAccount是针对程序访问APIserver的。</p>
<p>例如：ui程序在pod yaml配置文件里面指定ServiceAccount，在创建pod时引用ServiceAccount创建的token，token是保存在secret里面的，这样你的程序就带着token去访问apiserver，然后rbac是对ServiceAccount进行授权的。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s应用包管理器Helm初探</title>
    <url>/2022/07/15/k8s%E5%BA%94%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8helm%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="为什么需要Helm">为什么需要Helm</h2>
<p><img src="/images/18AA965627B942638BC076553CD7789Cclipboard.png" alt></p>
<p>由于Kubernetes缺少对发布的应用版本管理和控制，使得部署的应 用维护和更新等面临诸多的挑战，主要面临以下问题：</p>
<ul>
<li>
<p>如何将这些服务作为一个整体管理？</p>
</li>
<li>
<p>这些资源文件如何高效复用？</p>
</li>
<li>
<p>不支持应用级别的版本管理</p>
</li>
</ul>
<h2 id="Helm介绍">Helm介绍</h2>
<p>Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前 打包好的yaml文件部署到kubernetes上。</p>
<p>Helm有3个重要概念：</p>
<ul>
<li>
<p>helm：一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。</p>
</li>
<li>
<p>Chart：应用描述，一系列用于描述 k8s 资源相关文件的集合。</p>
</li>
<li>
<p>Release：基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在 k8s中创建出真实运行的资源对象。</p>
</li>
</ul>
<p>Helm目前有两个大版本：v2和v3</p>
<p>2019年11月Helm团队发布v3版本，相比v2版本最 大变化是将Tiller删除，并将大部分代码重构。</p>
<p><img src="/images/3821E58785BB4DCAAB4341A7EB2A7B98clipboard.png" alt></p>
<h2 id="Helm客户端">Helm客户端</h2>
<p>使用helm很简单，你只需要下载一个二进制客户端包即可，会通过kubeconfig配置（通常 $HOME/.kube/config）来连接Kubernetes。</p>
<p>下载Helm客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.2.4-linux-amd64.tar.gz</span><br><span class="line">tar zxvf helm-v3.2.4-linux-amd64.tar.gz </span><br><span class="line"><span class="built_in">mv</span> linux-amd64/helm /usr/bin/</span><br></pre></td></tr></table></figure>
<p><img src="/images/370E0ADEBC8049AA957517226C3D7E38clipboard.png" alt></p>
<h2 id="Helm基本使用">Helm基本使用</h2>
<p>Helm管理应用生命周期：</p>
<ul>
<li>
<p>helm create 制作Chart</p>
</li>
<li>
<p>helm install 部署</p>
</li>
<li>
<p>helm upgrade 更新</p>
</li>
<li>
<p>helm rollback 回滚</p>
</li>
<li>
<p>helm uninstall 卸载</p>
</li>
</ul>
<h2 id="Helm基本使用：制作Chart">Helm基本使用：制作Chart</h2>
<p>创建chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm create mychart </span><br></pre></td></tr></table></figure>
<p>打包chart：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm package mychart</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及 版本等。</p>
</li>
<li>
<p>values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。</p>
</li>
<li>
<p>Templates： 目录里面存放所有yaml模板文件。</p>
</li>
<li>
<p>charts：目录里存放这个chart依赖的所有子chart。</p>
</li>
<li>
<p>NOTES.txt ：用于介绍Chart帮助信息， helm install 部署后展示给用户。 例如：如何使用这个 Chart、列出缺省的设置等。</p>
</li>
<li>
<p>_helpers.tpl：放置模板的地方，可以在整个 chart 中重复使用。</p>
</li>
</ul>
<h2 id="Helm基本使用：部署">Helm基本使用：部署</h2>
<p>Helm核心是模板，即模板化K8s YAML文件。</p>
<p>部署多个应用时，将需要改动的字段进行模板 化，可动态传入。</p>
<p><img src="/images/C2E4292AE5C64932B9400425D070613Eclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mychart/templates/</span><br><span class="line"><span class="comment">#部署deployment</span></span><br><span class="line">vim deployment.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicas &#125;&#125; <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web1</span><br><span class="line">        image: &#123;&#123; .Values.image &#125;&#125;:&#123;&#123; .Values.imageTag &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署service</span></span><br><span class="line">vim service.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-service</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> mychart/</span><br><span class="line"><span class="comment">#渲染变量</span></span><br><span class="line">vim values.yaml</span><br><span class="line">replicas: 3</span><br><span class="line">image: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">imageTag: <span class="string">&quot;1.17&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#部署Chart：</span></span><br><span class="line">helm install web mychart/</span><br><span class="line"><span class="comment">#查看Release：</span></span><br><span class="line">helm list -n default</span><br><span class="line"><span class="comment">#查看部署的Pod：</span></span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<p><img src="/images/8AEE0351668B4BA986921D2584E58C14clipboard.png" alt></p>
<h2 id="Helm基本使用：升级">Helm基本使用：升级</h2>
<p>为了实现Chart复用，可动态传参修改values.yaml中的 变量值，有两种方式：</p>
<ul>
<li>
<p>–values，-f</p>
</li>
<li>
<p>–set</p>
</li>
</ul>
<p>例如将升级应用版本和副本数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade --<span class="built_in">set</span> imageTag=1.18,replicas=1 web mychart/</span><br><span class="line">helm list </span><br><span class="line">helm <span class="built_in">history</span> web   <span class="comment">#查看历史版本</span></span><br><span class="line">kubectl get pod -o wdie</span><br><span class="line">curl -I 10.244.36.67  <span class="comment">#访问验证是否升级到指定版本  </span></span><br></pre></td></tr></table></figure>
<p><img src="/images/FA77FD2C2FBB45C58F9290D439233EF1clipboard.png" alt></p>
<h2 id="Helm基本使用：回滚、卸载">Helm基本使用：回滚、卸载</h2>
<p>回滚到上一个版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web</span><br></pre></td></tr></table></figure>
<p>查看历史版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">history</span> web</span><br></pre></td></tr></table></figure>
<p>回滚到指定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback web 1</span><br></pre></td></tr></table></figure>
<p>卸载应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm uninstall web</span><br></pre></td></tr></table></figure>
<h2 id="Helm基本使用：工作流程">Helm基本使用：工作流程</h2>
<p><img src="/images/B139AB7AC42745A4A3F2E5687D96D0B6clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install web mychart/ --dry-run   <span class="comment">#尝试运行但不执行，调式</span></span><br><span class="line">helm install web mychart/</span><br><span class="line">helm get manifest web   <span class="comment">#显示web的清单</span></span><br></pre></td></tr></table></figure>
<h2 id="公共Chart仓库">公共Chart仓库</h2>
<p>国内Chart仓库，可直接使用它们制作好的包：</p>
<ul>
<li>
<p>微软仓库（<a href="http://mirror.azure.cn/kubernetes/charts/%EF%BC%89">http://mirror.azure.cn/kubernetes/charts/）</a></p>
</li>
<li>
<p>阿里云仓库（<a href="https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</a> ）</p>
</li>
<li>
<p>官方仓库（<a href="https://hub.kubeapps.com/charts/incubator%EF%BC%89">https://hub.kubeapps.com/charts/incubator）</a></p>
</li>
</ul>
<p>添加仓库方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add azure http://mirror.azure.cn/kubernetes/charts/</span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts </span><br><span class="line">helm repo update                       <span class="comment">#更新</span></span><br><span class="line">helm repo list                         <span class="comment">#列出当前的仓库</span></span><br><span class="line">helm search repo mysql                 <span class="comment">#搜索MySQL的chart包</span></span><br><span class="line">helm install mysql aliyun/mysql        <span class="comment">#安装</span></span><br><span class="line">helm pull aliyun/mysql --untar         <span class="comment">#从远程仓库中下载chart并解压到本地</span></span><br><span class="line">helm package mychart/                  <span class="comment">#打包自己的chart</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl命令行管理工具</title>
    <url>/2022/06/12/kubectl%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="kubeconfig配置文件">kubeconfig配置文件</h2>
<p>kube-apiserver两个端口：</p>
<ul>
<li>
<p>localhost:8080  非安全端口，是kubectl默认先连接8080，如果你配置kubeconfig（.kube/config）就直接走这个配置连接的安全端口</p>
</li>
<li>
<p>masterip:6443   安全端口</p>
</li>
</ul>
<p>命令行指定配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node --kubeconfig=admin.conf</span><br></pre></td></tr></table></figure>
<p>拷贝认证文件到其他节点的（.kube/config）下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp .kube/config root@192.168.0.12:.kube/</span><br></pre></td></tr></table></figure>
<p>kubectl使用kubeconfig认证文件连接K8s集群， 使用kubectl config指令生成kubeconfig文件。</p>
<p><img src="/images/44B7D7962FFC4A6084E5B03245B92B45clipboard.png" alt></p>
<h2 id="kubectl管理命令概要">kubectl管理命令概要</h2>
<p><img src="/images/B5A0EFF109924D819F7F247722B89244clipboard.png" alt></p>
<p>官方文档参考地址：<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></p>
<p><img src="/images/FE0CA664ABC643C6AC7DF7A84860042Cclipboard.png" alt></p>
<h2 id="牛刀小试，快速部署一个网站">牛刀小试，快速部署一个网站</h2>
<p>使用Deployment控制器部署镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=lizhenliang/java-demo </span><br><span class="line">kubectl get deploy,pods</span><br></pre></td></tr></table></figure>
<p>使用Service将Pod暴露出去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment web --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort </span><br><span class="line">kubectl get service</span><br></pre></td></tr></table></figure>
<p>访问应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://NodeIP:Port <span class="comment"># 端口随机生成，通过get svc获取</span></span><br></pre></td></tr></table></figure>
<h2 id="基本资源概念">基本资源概念</h2>
<ul>
<li>
<p>Pod：K8s最小部署单元，一组容器的集合</p>
</li>
<li>
<p>Deployment：最常见的控制器，用于更高级别部署和管理Pod</p>
</li>
<li>
<p>Service：为一组Pod提供负载均衡，对外提供统一访问入口</p>
</li>
<li>
<p>Label ：标签，附加到某个资源上，用于关联对象、查询和筛选</p>
</li>
<li>
<p>Namespaces ：命名空间，将对象逻辑上隔离，也利于权限控制</p>
</li>
</ul>
<h2 id="命名空间">命名空间</h2>
<p>命名空间（Namespace）：Kubernetes将资源对象逻辑上隔离，从而形成多个虚拟集群。</p>
<p>应用场景：</p>
<ul>
<li>
<p>根据不同团队划分命名空间</p>
</li>
<li>
<p>根据项目划分命名空间</p>
</li>
</ul>
<p>kubectl get namespace</p>
<ul>
<li>
<p>default：默认命名空间</p>
</li>
<li>
<p>kube-system：K8s系统方面的命名空间</p>
</li>
<li>
<p>kube-public：公开的命名空间，谁都可以访问，</p>
</li>
<li>
<p>kube-node-lease：K8s内部命名空间</p>
</li>
</ul>
<p>两种方法指定资源命名空间：</p>
<ul>
<li>
<p>命令行加 -n</p>
</li>
<li>
<p>yaml资源元数据里指定namespace字段</p>
</li>
</ul>
<p>1、使用kubeadm搭建一个K8s集群</p>
<p>2、新建命名空间，在该命名空间中创建一个pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace azhe</span><br></pre></td></tr></table></figure>
<p>3、创建一个deployment并暴露Service，可以在浏览器访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment java-demo --image=lizhenliang/java-demo -n azhe </span><br><span class="line">kubectl expose deployment java-demo --port 80 --target-port=8080 --<span class="built_in">type</span>=NodePort  -n azhe </span><br></pre></td></tr></table></figure>
<p>4、列出命名空间下指定标签pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n azhe --show-labels</span><br><span class="line">kubectl get pod -l app=java-demo -n azhe </span><br><span class="line">kubectl get pod,svc,deploy -o wide -n azhe  <span class="comment">#查看azhe命名空间下的pod，svc,deploy资源</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4D8950519EAC4C08B9D400C984FD4308clipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes核心概念</title>
    <url>/2022/06/10/kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="有了Docker，为什么还用Kubernetes？">有了Docker，为什么还用Kubernetes？</h2>
<p>为提高业务并发和高可用，会使用多台服务器，因此会面向这些问题：</p>
<ul>
<li>
<p>多容器跨主机提供服务</p>
</li>
<li>
<p>多容器分布节点部署</p>
</li>
<li>
<p>多容器怎么升级</p>
</li>
<li>
<p>怎么高效管理这些容器</p>
</li>
</ul>
<p><img src="/images/28FBDEB7C0804F9C9A9E53A5C9DEC0C5clipboard.png" alt></p>
<p>容器编排系统：</p>
<ul>
<li>
<p>Kubernetes</p>
</li>
<li>
<p>Swarm</p>
</li>
<li>
<p>Mesos Marathon</p>
</li>
</ul>
<p><img src="/images/B1FE2493A067433EBB99A47D55740E33clipboard.png" alt></p>
<h2 id="Kubernetes是什么">Kubernetes是什么</h2>
<ul>
<li>
<p>Kubernetes是Google在2014年开源的一个容器集群管理系统，Kubernetes简称K8s。</p>
</li>
<li>
<p>Kubernetes用于容器化应用程序的部署，扩展和管理，目标是让部署容器化应用简单高效</p>
</li>
</ul>
<p>官方网站：<a href="http://www.kubernetes.io/">http://www.kubernetes.io/</a></p>
<p>官方文档：<a href="https://kubernetes.io/zh/docs/home/">https://kubernetes.io/zh/docs/home/</a></p>
<h2 id="Kubernetes集群架构与组件">Kubernetes集群架构与组件</h2>
<p><img src="/images/2C6E9B5C538E4A97A18CC499EFCC98ADclipboard.png" alt></p>
<p><img src="/images/FF51CE19DAFF43B6AEB17650553CE68Aclipboard.png" alt></p>
<h3 id="Master组件">Master组件</h3>
<p>kube-apiserver</p>
<p>Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对			   象资源的增删改查和监听操作都交给 APIServer处理后再提交给Etcd存储。</p>
<p>kube-controller-manager</p>
<p>处理集群中常规后台任务，一个资源对应一个控制器，而 ControllerManager就是负责管理这些控制器的。</p>
<p>kube-scheduler</p>
<p>根据调度算法为新创建的Pod选择一个Node节点，可以任意部署, 可以部署在同一个节点上,也可以部署在不同的节点上。</p>
<p>etcd</p>
<p>分布式键值存储系统。用于保存集群状态数据，比如Pod、Service 等对象信息。</p>
<h3 id="Node组件">Node组件</h3>
<p>kubelet</p>
<p>kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周 期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态 等工作。kubelet将每个Pod转换成一组容器。</p>
<p>kube-proxy</p>
<p>在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。</p>
<p>docker或rocket</p>
<p>容器引擎，运行容器。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Service(对外暴露你的应用）</title>
    <url>/2022/06/17/service%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Service是什么与Service存在的意义">Service是什么与Service存在的意义</h2>
<p>Service引入主要是解决Pod的动态变化，提供统一访问入口：</p>
<ul>
<li>
<p>防止Pod失联，准备找到提供同一个服务的Pod（服务发现）</p>
</li>
<li>
<p>定义一组Pod的访问策略（负载均衡）</p>
</li>
</ul>
<p><img src="/images/46FCA6D1D1DE4CB1BF7404E3E644AB9Bclipboard.png" alt></p>
<h3 id="Pod与Service的关系">Pod与Service的关系</h3>
<ul>
<li>
<p>Service通过标签关联一组Pod</p>
</li>
<li>
<p>Service使用iptables或者ipvs为一组Pod提供负载均衡能力</p>
</li>
</ul>
<p><img src="/images/D28365050B2C4212BD3B918D4E543123clipboard.png" alt></p>
<h3 id="Service定义与创建">Service定义与创建</h3>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建service： </span></span><br><span class="line">kubectl apply -f service.yaml </span><br><span class="line"><span class="comment">#查看service： </span></span><br><span class="line">kubectl get service</span><br><span class="line"><span class="comment">#查看service关联一组pod的IP</span></span><br><span class="line">kubectl get endpoints</span><br></pre></td></tr></table></figure>
<h2 id="Service三种类型">Service三种类型</h2>
<ul>
<li>
<p>ClusterIP：集群内部使用</p>
</li>
<li>
<p>NodePort：对外暴露应用（集群外）</p>
</li>
<li>
<p>LoadBalancer：对外暴露应用，适用公有云</p>
</li>
</ul>
<p>ClusterIP：默认，分配一个稳定的IP地址，即VIP，只能在集群内部访问。</p>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl 10.107.214.48    <span class="comment">#访问集群内部暴露的service的IP及端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4BC1CA5B289A4AABB644197644BFCF13clipboard.png" alt></p>
<p><img src="/images/57A69C2E53F6499B858D3C247528F7B3clipboard.png" alt></p>
<p>NodePort：在每个节点上启用一个端口来暴露服务，可以在集群 外部访问。也会分配一个稳定内部集群IP地址。 访问地址：&lt;任意NodeIP&gt;: 端口范围：30000-32767</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">http://192.168.1.12:30009/  <span class="comment">#访问集群外部节点IP以及暴露的端口</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/9D738F0AF4584DA38F71D1BC618DE8ACclipboard.png" alt></p>
<p><img src="/images/160A670AE9A44000B53A589FE400605Bclipboard.png" alt></p>
<p>NodePort：会在每台Node上监听端口接收用户流量，在实际情 况下，对用户暴露的只会有一个IP和端口，那这么多台Node该使 用哪台让用户访问呢？</p>
<p>这时就需要前面加一个公网负载均衡器为项目提供统一访问入口了。</p>
<p><img src="/images/D7C5CA3D9A9F4C41BD5E5FFDC2AF08F4clipboard.png" alt></p>
<p>负载均衡器：</p>
<ul>
<li>
<p>开源：nginx、lvs、haproxy</p>
</li>
<li>
<p>公有云：SLB</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream demo &#123;</span><br><span class="line">	server 192.168.0.11:30008;</span><br><span class="line">	server 192.168.0.12:30008;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo2 &#123;</span><br><span class="line">	server 192.168.0.13:30009;</span><br><span class="line">	server 192.168.0.14:30009;</span><br><span class="line">&#125;</span><br><span class="line">upstream demo3 &#123;</span><br><span class="line">	server 192.168.0.15:30010;</span><br><span class="line">	server 192.168.0.16:30010;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name a.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name b.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	server_name c.xxx.com;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://demo3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadBalancer：与NodePort类似，在每个节点上启用一个端口来暴 露服务。除此之外，Kubernetes会请求底层云平台（例如阿里云、腾 讯云、AWS等）上的负载均衡器，将每个Node （[NodeIP]:[NodePort]）作为后端添加进去。</p>
<p><img src="/images/57137C13B9A640EE8D7C367E149ADB23clipboard.png" alt></p>
<h2 id="Service代理模式">Service代理模式</h2>
<p>Service的底层实现主要有iptables和ipvs二种网络模式，决定了如何转发流量</p>
<p><img src="/images/45B9E4A9C42543FFAE1E1DBF9241EFDEclipboard.png" alt></p>
<p>基于iptables实现负载均衡的一个过程</p>
<p>1、在浏览器访问 <a href="http://192.168.0.11:30009/">http://192.168.0.11:30009/</a></p>
<p>2.数据包经过iptables规则匹配，重定向到另一个链KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p>-A KUBE-NODEPORTS -p tcp -m comment --comment “default/web” -m tcp --dport 30009 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/A0F68B2B033F444B8146083059B79962clipboard.png" alt></p>
<p>3.一组规则，有几个pod就会创建几条规则，这里实现了负载均衡 （概率1/3，1/2，1）</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.33333333349 -j KUBE-SEP-PXRBKXV7I65SLLDB</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-4MXWCRSI3HRHILKZ</p>
<p>-A KUBE-SVC-LOLE4ISW44XBNF3G -m comment --comment “default/web” -j KUBE-SEP-ODUGDMBPYLOH457E</p>
<p><img src="/images/1423425BFBBC4CF7B8B6547BDB6AA417clipboard.png" alt></p>
<p>4.使用DNAT转发到具体的pod</p>
<p>-A KUBE-SEP-PXRBKXV7I65SLLDB -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.169.133:80</p>
<p><img src="/images/94448BF326BD473983D7823BCE74D6A2clipboard.png" alt></p>
<p>-A KUBE-SEP-4MXWCRSI3HRHILKZ -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.67:80</p>
<p><img src="/images/2DC4797D7765429D852EBB7A5E6C32EEclipboard.png" alt></p>
<p>-A KUBE-SEP-ODUGDMBPYLOH457E -p tcp -m comment --comment “default/web” -m tcp -j DNAT --to-destination 10.244.36.68:80</p>
<p><img src="/images/31B2F70ADDAD4CA3AED602FECACBBC56clipboard.png" alt></p>
<p>针对ClusterIP实现的转发，后面与nodeport一样，回到了上面的第三步</p>
<p>-A KUBE-SERVICES -d 10.109.90.58/32 -p tcp -m comment --comment “default/web cluster IP” -m tcp --dport 80 -j KUBE-SVC-LOLE4ISW44XBNF3G</p>
<p><img src="/images/3CC81396D80F4171A1FDACC13E9C54D8clipboard.png" alt></p>
<p>kubeadm方式修改ipvs模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit configmaps kube-proxy -n kube-system </span><br><span class="line"><span class="comment">#搜索mode，添加ipvs，修改完保存</span></span><br><span class="line">  mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line"><span class="comment">#删除node1节点proxy的pod,重新生成新的pod</span></span><br><span class="line">kubectl delete pod kube-proxy-lzjgg -n kube-system </span><br><span class="line">kubectl get pod -o wide -n kube-system </span><br><span class="line">kubectl logs kube-proxy-hnw5p -n kube-system </span><br></pre></td></tr></table></figure>
<p><img src="/images/A3F8D2A415C546398858681A0512333Dclipboard.png" alt></p>
<p>注： 1、kube-proxy配置文件以configmap方式存储 2、如果让所有节点生效，需要重建所有节点kube-proxy pod</p>
<p>在node1节点上安装ipvsadm工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ipvsadm</span><br><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/9ECAC01183284036B4DFF293FB29FA02clipboard.png" alt></p>
<p>ip a</p>
<p><img src="/images/C1397ED986B04C628380BEFC3B50A968clipboard.png" alt></p>
<p>二进制方式修改ipvs模式：</p>
<p>vi kube-proxy-config.yml</p>
<p>mode: ipvs</p>
<p>ipvs:</p>
<p>scheduler: &quot;rr“</p>
<p>systemctl restart kube-proxy</p>
<p>注：参考不同资料，文件名可能不同</p>
<p>流程包流程：客户端 -&gt;NodePort/ClusterIP（iptables/Ipvs负载均衡规则） -&gt; 分布在各节点Pod</p>
<p>查看负载均衡规则：</p>
<ul>
<li>iptables模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save |grep </span><br></pre></td></tr></table></figure>
<ul>
<li>ipvs模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>
<p><img src="/images/48DCC6F8FF224A899C3AF23FC8AD0B8Eclipboard.png" alt></p>
<p>当一个客户端访问service的时候，经过iptables/ipvs进行负载均衡，负载到后端的pod上，iptables/ipvs的规则是由kube-proxy去创建的。</p>
<p>当出现问题的时候，应该先检查的service的配置的是不是对的（标签端口等等），再检查kube-proxy是不是正常的，有没有创建对应的iptables/ipvs规则。</p>
<h2 id="Service-DNS名称">Service DNS名称</h2>
<p>CoreDNS：是一个DNS服务器，Kubernetes默认采用，以Pod部署在集群中，CoreDNS服 务监视Kubernetes API，为每一个Service创建DNS记录用于域名解析。</p>
<p>CoreDNS YAML文件：</p>
<p><a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns">https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/coredns</a></p>
<p>ClusterIP A记录格式：<service-name>.<namespace-name>.svc.cluster.local</namespace-name></service-name></p>
<p>示例：my-svc.my-namespace.svc.cluster.local</p>
<p><img src="/images/ECF12D7CD8F145629E5BF72FD6A79F77clipboard.png" alt></p>
<p><img src="/images/4C475116BD954880B84C0AD18D7301A2clipboard.png" alt></p>
<p>当我们在pod内做nslookup(dns)解析时，它会请求coredns pod，coredns里面存放了从k8smaster中获取的service对应的dns记录，就会帮你解析成对应service的IP。</p>
<p>Iptables VS IPVS</p>
<p>Iptables：</p>
<ul>
<li>
<p>灵活，功能强大</p>
</li>
<li>
<p>规则遍历匹配和更新，呈线性时延</p>
</li>
</ul>
<p>IPVS：</p>
<ul>
<li>
<p>工作在内核态，有更好的性能</p>
</li>
<li>
<p>调度算法丰富：rr，wrr，lc，wlc，ip hash…</p>
</li>
</ul>
<p>生产环境建议使用IPVS</p>
<p>1、创建一个deployment 副本数 3，然后滚动更新镜像版本，并记录这个更新记录，最后再回滚到上一个版本</p>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line"><span class="comment">#通过命令更新镜像，指定--record参数会将这条命令记录到历史版本记录中，方便回滚到对应的版本</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.16 --record  </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl  -I10.244.169.140   <span class="comment">#验证是否是nginx1.16版本</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web-deployment  <span class="comment">#查看历史版本记录</span></span><br><span class="line">kubectl rollout undo deployment web-deployment  <span class="comment">#默认回滚到上一个版本</span></span><br><span class="line">kubectl get pod -o wide    <span class="comment">#查看pod的IP</span></span><br><span class="line">curl -I 10.244.36.76   <span class="comment">#验证是否回滚到nginx1.15版本</span></span><br></pre></td></tr></table></figure>
<p>2、给一个应用扩容副本数为3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment web-deployment --replicas=6</span><br><span class="line">kubectl get pod </span><br></pre></td></tr></table></figure>
<p>3、创建一个pod，其中运行着nginx、redis、memcached 3个容器</p>
<p>vim nginx-redis-memcached.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-redis-memcached</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">      containers:</span><br><span class="line">      - name: redis</span><br><span class="line">        image: redis</span><br><span class="line">      containers:</span><br><span class="line">      - name: memcached</span><br><span class="line">        image: memcached</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-redis-memcached.yaml </span><br><span class="line">kubectl get pod</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm nginx -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm redis -- bash</span><br><span class="line">kubectl <span class="built_in">exec</span> -it web-deployment-7c6bf5fdf8-8m2gm memcached -- bash</span><br></pre></td></tr></table></figure>
<p>4、给一个pod创建service，并可以通过ClusterIP/NodePort访问</p>
<p>vim service-node.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort <span class="comment"># 服务类型</span></span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 <span class="comment"># Service端口</span></span><br><span class="line">    protocol: TCP <span class="comment"># 协议</span></span><br><span class="line">    targetPort: 80 <span class="comment"># 容器端口</span></span><br><span class="line">    nodePort: 30009    <span class="comment">#nodeport暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: web <span class="comment"># 指定关联Pod的标签</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service-node.yaml </span><br><span class="line">kubectl get svc</span><br><span class="line">curl  -I 10.105.40.240   <span class="comment">#访问集群内部service IP</span></span><br><span class="line">http://192.168.0.12:30009/    <span class="comment">#访问任意node节点IP加30009端口</span></span><br></pre></td></tr></table></figure>
<p>5、创建deployment和service，使用busybox容器nslookup解析service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it dns-test --image=busybox -- sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/810CBA00E6294D12A8014902A6EC2B6Fclipboard.png" alt></p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈有状态应用部署：StatefulSet控制器</title>
    <url>/2022/07/13/%E5%86%8D%E8%B0%88%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2statefulset%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="无状态与有状态">无状态与有状态</h2>
<p>Deployment控制器设计原则：管理的所有Pod一模一样，提供同一个服务，也不考虑在哪台Node 运行，可随意扩容和缩容。这种应用称为“无状态”，例如Web服务</p>
<p>在实际的场景中，并不能满足所有应用，尤其是分布式应用，会部署多个实例，这些实例之间往往有 依赖关系，例如主从关系、主备关系，这种应用称为“有状态”，例如MySQL主从、Etcd集群</p>
<h2 id="StatefulSet-控制器概述">StatefulSet 控制器概述</h2>
<p>StatefulSet控制器用于部署有状态应用，满足一些有状态应 用的需求：</p>
<ul>
<li>
<p>Pod有序的部署、扩容、删除和停止</p>
</li>
<li>
<p>Pod分配一个稳定的且唯一的网络标识</p>
</li>
<li>
<p>Pod分配一个独享的存储</p>
</li>
</ul>
<h2 id="StatefulSet-控制器：网络标识">StatefulSet 控制器：网络标识</h2>
<p>稳定的网络标识：使用Headless Service（相比普通Service只是将spec.clusterIP定义为None）来维 护Pod网络身份，会为每个Pod分配一个数字编号并且按照编号顺序部署。还需要在StatefulSet添加 serviceName: “nginx”字段指定StatefulSet控制器要使用这个Headless Service。</p>
<p>稳定主要体现在主机名和Pod A记录：</p>
<p>主机名：&lt;statefulset名称&gt;-&lt;编号&gt;</p>
<p>Pod DNS A记录：&lt;statefulset名称-编号&gt;.<service-name>.<namespace>.svc.cluster.local</namespace></service-name></p>
<p>部署statefulset控制器</p>
<p>vim statefulset-web.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;handless-service&quot;</span></span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署handless-service</p>
<p>vim handless-service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: handless-service</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f statefulset-web.yaml</span><br><span class="line">kubectl apply -f handless-service.yaml </span><br><span class="line">kubectl get pod,svc</span><br><span class="line">kubectl get statefulsets.apps </span><br></pre></td></tr></table></figure>
<p>查看Pod创建顺序：</p>
<p><img src="/images/80B71B676C07446E9B2AA1C978F26318clipboard.png" alt></p>
<p>查看主机名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-0 -- hostname</span><br><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-1 -- hostname</span><br><span class="line">kubectl <span class="built_in">exec</span> statefulset-web-2 -- hostname</span><br></pre></td></tr></table></figure>
<p><img src="/images/755E9E6EDA8941558B1745290F2D917Cclipboard.png" alt></p>
<p>测试A记录解析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it dns-test --<span class="built_in">rm</span> --image=busybox:1.28.4 -- sh</span><br><span class="line">nslookup handless-service </span><br></pre></td></tr></table></figure>
<p>解析出对应的三个Pod IP记录，其他Pod可使用这个名称访问：</p>
<p><img src="/images/FAC6C069723344C2A0DB0C8F849AE00Dclipboard.png" alt></p>
<h2 id="StatefulSet-控制器：独享存储">StatefulSet 控制器：独享存储</h2>
<p>独享存储：StatefulSet的存储卷使用VolumeClaimTemplate创建，称为卷申请模板，当StatefulSet使用 VolumeClaimTemplate创建一个PersistentVolume时，同样也会为每个Pod分配并创建一个编号的PVC， 每个PVC绑定对应的PV，从而保证每个Pod都拥有独立的存储。</p>
<p>部署nfs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试在别的K8s节点挂载nfs共享目录</span></span><br><span class="line">mount -t nfs 192.168.0.13:/nfs/kubernetes /mnt/</span><br></pre></td></tr></table></figure>
<p>部署nfs-storage</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line"></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p>部署statefulset控制器</p>
<p>vim statefulset-web.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: statefulset-web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;handless-service&quot;</span></span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: www</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">  volumeClaimTemplates:</span><br><span class="line">  - metadata:</span><br><span class="line">      name: www</span><br><span class="line">    spec:</span><br><span class="line">      storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">      accessModes:</span><br><span class="line">      - ReadWriteOnce</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          storage: 1G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f statefulset-web.yaml </span><br><span class="line">kubectl apply -f statefulset-web.yaml </span><br></pre></td></tr></table></figure>
<p><img src="/images/050E337CBA4347278B9D0F4B2D7BBB2Aclipboard.png" alt></p>
<p>nfs服务器共享目录</p>
<p><img src="/images/BD3FFB854BCE4CEF8A11A7EE1B494B72clipboard.png" alt></p>
<p>测试在这三个pv目录下创建三个不同内容的index.html页面，然后访问对应不同的Pod的IP</p>
<p><img src="/images/BDD71F15C8FF4D99B2BC00D24806B61Dclipboard.png" alt></p>
<p>验证访问</p>
<p><img src="/images/127B91087C4C4170B0479529BD161B90clipboard.png" alt></p>
<p>从上面图中，我们可以看到每个pod的数据都是独立存储的。</p>
<p>测试删除statefulset控制器</p>
<p><img src="/images/F37B91C5C39D4B548C6632FF7971A806clipboard.png" alt></p>
<p>从上图可以看出，当我们删除pod的时候，并没有删除对应pvc和pv，而是做了数据的持久化。</p>
<p>再次重建测试能否访问之前的数据</p>
<p><img src="/images/907C87901FA54AF4A7B760C74CB4BBF7clipboard.png" alt></p>
<p><img src="/images/AF4D65A9A4C84C3DB178061646047519clipboard.png" alt></p>
<p>从上图可以看出，重建之后，数据还是之前的数据，每个pvc对应绑定每个pv，pod的IP发生了变化。</p>
<p>kubernetes根据pod的编号找同样编号的pvc去挂载，从而实现了数据持久化。</p>
<p>通过编号保证每个pod的启动顺序</p>
<p>通过编号为每个pod创建不同的主机名以及dns A记录</p>
<p>通过编号为每个pod创建独立的pvc</p>
<h2 id="StatefulSet-控制器：小结">StatefulSet 控制器：小结</h2>
<p>StatefulSet与Deployment区别：有身份的！</p>
<p>身份三要素：</p>
<ul>
<li>
<p>域名</p>
</li>
<li>
<p>主机名</p>
</li>
<li>
<p>存储（PVC）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker构建企业Jenkins平台</title>
    <url>/2022/05/27/%E5%9F%BA%E4%BA%8Edocker%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9Ajenkins%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>CI/CD概述</p>
<p>持续集成（Continuous Integration，CI）：代码合并、构建、部署、测试都在一起，不断地执行这个过程，并对结果反馈。</p>
<p>持续部署（Continuous Deployment，CD）：部署到测试环境、预生产环境、生产环境。</p>
<p>持续交付（Continuous Delivery，CD）：将最终产品发布到生产环境，给用户使用。</p>
<p><img src="/images/D06234A999FE473FBA13400A79F2390Aclipboard.png" alt></p>
<p>CI工作流程设计</p>
<p><img src="/images/3C3FFAC3EFE24641B2E3746166FFDD5Eclipboard.png" alt></p>
<p>开发者提交代码到gitlab仓库，gitlab随后触发jenkins代码编译，构建镜像以及推送镜像到harbor仓库，紧接着Jenkins部署到docker主机（从harbor仓库拉取镜像到本地部署启动）。</p>
<table>
<thead>
<tr>
<th>gitlab主机</th>
<th>jenkins主机</th>
<th>harbor主机</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.11/24</td>
<td>192.168.0.13/24</td>
<td>192.168.0.12/24</td>
</tr>
</tbody>
</table>
<pre><code>                                                       项目环境表
</code></pre>
<p>1、部署Gitlab</p>
<p>1.1 部署Gitlab</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gitlab</span><br><span class="line"><span class="built_in">cd</span> gitlab</span><br><span class="line">docker run -d \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  -p 8443:443 \</span><br><span class="line">  -p 9999:80 \</span><br><span class="line">  -p 9998:22 \</span><br><span class="line">  -v <span class="variable">$PWD</span>/config:/etc/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/logs:/var/log/gitlab \</span><br><span class="line">  -v <span class="variable">$PWD</span>/data:/var/opt/gitlab \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  --restart=always \</span><br><span class="line">  lizhenliang/gitlab-ce-zh:latest</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP:9999">http://IP:9999</a></p>
<p>初次会先设置管理员密码 ，然后登陆，默认管理员用户名root，密码就是刚设置的。</p>
<p>1.2 创建项目，提交测试代码</p>
<p>进入后先创建项目，提交代码，以便后面测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip tomcat-java-demo-master.zip</span><br><span class="line"><span class="built_in">cd</span> tomcat-java-demo-master</span><br><span class="line">git init</span><br><span class="line">git remote add origin http://192.168.0.11:9999/root/java-demo.git</span><br><span class="line">git add .</span><br><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git commit -m <span class="string">&#x27;all&#x27;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>2、部署Harbor镜像仓库</p>
<p>2.1 安装docker与docker-compose</p>
<p>2.2 解压离线包部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v2.0.0.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># cp harbor.yml.tmpl harbor.yml</span></span><br><span class="line"><span class="comment"># vi harbor.yml</span></span><br><span class="line">hostname: reg.ctnrs.com</span><br><span class="line">https:   <span class="comment"># 先注释https相关配置</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh</span></span><br></pre></td></tr></table></figure>
<p>2.3 在Jenkins主机配置Docker可信任，如果是HTTPS需要拷贝证书</p>
<p>由于habor未配置https，还需要在docker配置可信任。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.0.12&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<p>2.4 构建tomcat镜像并上传到harbor仓库上（供jenkinsfile脚本调用）</p>
<p>#准备的安装包（apache-tomcat-8.5.43.tar.gz）和Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.43</span><br><span class="line"></span><br><span class="line">RUN yum install java-1.8.0-openjdk wget curl unzip iproute net-tools -y &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz /usr/local/</span><br><span class="line">RUN <span class="built_in">mv</span> /usr/local/apache-tomcat-<span class="variable">$&#123;VERSION&#125;</span> /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&#x27;1a JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/./urandom&quot;&#x27;</span> /usr/local/tomcat/bin/catalina.sh &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/tomcat/bin</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/tomcat</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构建并上传到harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t 192.168.0.12/library/tomcat:v1 .</span><br><span class="line">docker login 192.168.0.12</span><br><span class="line">docker /images</span><br><span class="line">docker push 192.168.0.12/library/tomcat:v1</span><br></pre></td></tr></table></figure>
<p><img src="/images/725360157F1C4DF0B88A2EDA4C641CA8clipboard.png" alt></p>
<p>3、部署Jenkins</p>
<p>3.1 准备JDK和Maven环境</p>
<p>将二进制包上传到服务器并解压到工作目录，用于让Jenkins容器挂载使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar zxvf jdk-8u45-linux-x64.tar.gz</span></span><br><span class="line"><span class="comment"># mv jdk1.8.0_45 /usr/local/jdk</span></span><br><span class="line"><span class="comment"># tar zxf apache-maven-3.5.0-bin.tar.gz</span></span><br><span class="line"><span class="comment"># mv apache-maven-3.5.0 /usr/local/maven</span></span><br></pre></td></tr></table></figure>
<p>修改Maven源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/local/maven/conf/setting.xml</span><br><span class="line"></span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line"></span><br><span class="line">&lt;mirror&gt;     </span><br><span class="line">  &lt;<span class="built_in">id</span>&gt;central&lt;/id&gt;     </span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;     </span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;     </span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>
<p>部署jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 80:8080 -p 50000:50000 -u root  \</span><br><span class="line">   -v /opt/jenkins_home:/var/jenkins_home \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock   \</span><br><span class="line">   -v /usr/bin/docker:/usr/bin/docker \</span><br><span class="line">   -v /usr/local/maven:/usr/local/maven \</span><br><span class="line">   -v /usr/local/jdk:/usr/local/jdk \</span><br><span class="line">   -v /etc/localtime:/etc/localtime \</span><br><span class="line">   --restart=always \</span><br><span class="line">   --name jenkins jenkins/jenkins</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://IP">http://IP</a></p>
<p>3.2 安装插件</p>
<p>管理Jenkins-&gt;系统配置–&gt;管理插件**–&gt;搜索git/pipeline，选中点击安装。</p>
<p>默认从国外网络下载插件，会比较慢，建议修改国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jenkins_home/updates</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27;</span> default.json &amp;&amp; \</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27;</span> default.json</span><br><span class="line"></span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>
<p>3.3 Jenkins Pipeline介绍</p>
<p>Jenkins Pipeline是一套插件，支持在Jenkins中实现集成和持续交付管道；</p>
<p>Pipeline通过特定语法对简单到复杂的传输管道进行建模；</p>
<p>声明式：遵循与Groovy相同语法。pipeline { }</p>
<p>脚本式：支持Groovy大部分功能，也是非常表达和灵活的工具。node { }</p>
<p>Jenkins Pipeline的定	义被写入一个文本文件，称为Jenkinsfile。</p>
<p><img src="/images/A721BDDA11234FEFBB2D6AFBA3C673CAclipboard.png" alt></p>
<p><img src="/images/3EAC878934A84E509B25BFCF9A463E62clipboard.png" alt></p>
<p><img src="/images/A3A3BF02751C4D79B7ACEC54F86C0CDFclipboard.png" alt></p>
<p>注意： 发布之前可以在jenkins主机上测试一下是否能登录harbor仓库</p>
<p>如果不能登录报错为连接443拒绝，那么请使用以下方式解决：</p>
<p>修改Docker启动文件添加“–insecure-registry 192.168.0.12”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 192.168.0.12</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>4、发布测试</p>
<p>4.1添加连接git仓库凭据和harbor仓库凭据</p>
<p>管理Jenkins-&gt;安全–&gt;管理凭据-&gt;Jnekins-&gt;添加凭据-&gt;Username with password</p>
<ul>
<li>
<p>Username：用户名</p>
</li>
<li>
<p>Password：密码</p>
</li>
<li>
<p>ID：留空</p>
</li>
<li>
<p>Description：描述</p>
</li>
</ul>
<p>分别添加连接git和harbor凭据，并修改脚本为实际凭据ID。</p>
<p><img src="/images/028FE8C5C63C44E19CBEECC88334DC65clipboard.png" alt></p>
<p>4.2 创建项目并配置</p>
<p>New Item -&gt; Pipeline -&gt; This project is parameterized -&gt; String Parameter</p>
<ul>
<li>
<p>Name：Branch    # 变量名，下面脚本中调用</p>
</li>
<li>
<p>Default Value：master   # 默认分支</p>
</li>
<li>
<p>Description：发布的代码分支  # 描述</p>
</li>
</ul>
<p><img src="/images/7A9EA62F8A9F4D97991A4AB427F6EDC5clipboard.png" alt></p>
<p>4.3 Pipeline脚本（在Jenkins本地机器上部署并启动容器）</p>
<p>一. 添加注释方便查看使用说明（添加注释到jenkins执行会报错，请使用第二个构建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      <span class="comment">#harbor仓库地址</span></span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                <span class="comment">#harbor仓库项目名</span></span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>         <span class="comment">#镜像的应用名</span></span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>  <span class="comment">#Branch代表引用的分支名</span></span><br><span class="line">                                                                                 <span class="comment">#BUILD_NUMBER代表构建编号</span></span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>        <span class="comment">#git仓库连接地址</span></span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>      <span class="comment">#harbor仓库认证（用户名和密码）</span></span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  <span class="comment">#git仓库认证（用户名和密码）</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二.请使用这个pipeline脚本构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>                  </span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">              sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">              docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">              docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">              &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述脚本中，docker_registry_auth 和git_auth变量的值为Jenkins凭据ID，添加凭据后修改。</p>
<p>4.4 Pipeline脚本（ 在其他的Docker主机上部署并启动容器）</p>
<p>安装jenkins插件</p>
<p>插件名称： SSH Pipeline Steps</p>
<p>使用说明: <a href="https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps">https://github.com/jenkinsci/ssh-steps-plugin#pipeline-steps</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line"></span><br><span class="line">def registry = <span class="string">&quot;192.168.0.12&quot;</span>      </span><br><span class="line">def project = <span class="string">&quot;dev&quot;</span>                </span><br><span class="line">def app_name = <span class="string">&quot;java-demo&quot;</span>        </span><br><span class="line">def image_name = <span class="string">&quot;<span class="variable">$&#123;registry&#125;</span>/<span class="variable">$&#123;project&#125;</span>/<span class="variable">$&#123;app_name&#125;</span>:<span class="variable">$&#123;Branch&#125;</span>-<span class="variable">$&#123;BUILD_NUMBER&#125;</span>&quot;</span>                                                                                </span><br><span class="line">def git_address = <span class="string">&quot;http://192.168.0.11:9999/root/java-demo.git&quot;</span>      </span><br><span class="line">def docker_registry_auth = <span class="string">&quot;30fae7e1-22c4-4083-848f-a5e90eff9e1f&quot;</span>     </span><br><span class="line">def git_auth = <span class="string">&quot;05750892-5303-49ab-a6d0-33a78ef6c839&quot;</span>   </span><br><span class="line">def remote = [:]</span><br><span class="line">    remote.name = <span class="string">&quot;test&quot;</span></span><br><span class="line">    remote.host = <span class="string">&quot;192.168.0.12&quot;</span></span><br><span class="line">    remote.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    remote.password = <span class="string">&#x27;123.com&#x27;</span></span><br><span class="line">    remote.allowAnyHosts = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">              checkout([<span class="variable">$class</span>: <span class="string">&#x27;GitSCM&#x27;</span>, branches: [[name: <span class="string">&#x27;$&#123;Branch&#125;&#x27;</span>]], userRemoteConfigs: [[credentialsId: <span class="string">&quot;<span class="variable">$&#123;git_auth&#125;</span>&quot;</span>, url: <span class="string">&quot;<span class="variable">$&#123;git_address&#125;</span>&quot;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;代码编译&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">             sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                pwd</span></span><br><span class="line"><span class="string">                ls</span></span><br><span class="line"><span class="string">                JAVA_HOME=/usr/local/jdk</span></span><br><span class="line"><span class="string">                PATH=<span class="variable">$JAVA_HOME</span>/bin:/usr/local/maven/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">                mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span> </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;构建镜像&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                withCredentials([usernamePassword(credentialsId: <span class="string">&quot;<span class="variable">$&#123;docker_registry_auth&#125;</span>&quot;</span>, passwordVariable: <span class="string">&#x27;password&#x27;</span>, usernameVariable: <span class="string">&#x27;username&#x27;</span>)]) &#123;</span><br><span class="line">                sh <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                  echo &#x27;</span></span><br><span class="line"><span class="string">                    FROM <span class="variable">$&#123;registry&#125;</span>/library/tomcat:v1</span></span><br><span class="line"><span class="string">                    LABEL maitainer liuzhe</span></span><br><span class="line"><span class="string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span></span><br><span class="line"><span class="string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span></span><br><span class="line"><span class="string">                  &#x27; &gt; Dockerfile</span></span><br><span class="line"><span class="string">                  docker build -t <span class="variable">$&#123;image_name&#125;</span> .</span></span><br><span class="line"><span class="string">                  docker login -u <span class="variable">$&#123;username&#125;</span> -p &#x27;<span class="variable">$&#123;password&#125;</span>&#x27; <span class="variable">$&#123;registry&#125;</span></span></span><br><span class="line"><span class="string">                  docker push <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(<span class="string">&#x27;部署到Docker&#x27;</span>)&#123;</span><br><span class="line">           steps &#123;</span><br><span class="line">                sshCommand remote: remote, <span class="built_in">command</span>: <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                ip a</span></span><br><span class="line"><span class="string">                docker rm -f tomcat-java-demo |true</span></span><br><span class="line"><span class="string">                docker pull <span class="variable">$&#123;image_name&#125;</span> </span></span><br><span class="line"><span class="string">                docker container run -d --name tomcat-java-demo -p 88:8080 <span class="variable">$&#123;image_name&#125;</span></span></span><br><span class="line"><span class="string">               &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p>1.访问harbor仓库查看是否有上传的镜像    <a href="http://192.168.0.12/">http://192.168.0.12/</a></p>
<p><img src="/images/04418B7661DC49D1AD92114AC38F5A64clipboard.png" alt></p>
<p>2.docker主机上运行的项目镜像容器</p>
<p><img src="/images/03E31D0090E748B5B3B8416B4C4EEC4Cclipboard.png" alt></p>
<p>3.访问部署java-demo示例     <a href="http://192.168.0.13:88/">http://192.168.0.13:88/</a></p>
<p><img src="/images/5DF2722940214B15AB62A6AA70E96839clipboard.png" alt></p>
<p>CI/CD收益</p>
<p>高效的CI/CD环境可以获得：</p>
<p>1.及时发现问题</p>
<p>2.大幅度减少故障率</p>
<p>3.加快迭代速度</p>
<p>4.减少时间成本</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Docker容器多主机通信</title>
    <url>/2022/05/26/%E5%AE%9E%E7%8E%B0docker%E5%AE%B9%E5%99%A8%E5%A4%9A%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>跨主机网络：实现Docker容器多主机通信</p>
<p>Flannel是CoreOS维护的一个网络组件，在每个主机上运行守护 进程负责维护本地路由转发，Flannel使用ETCD来存储容器网络 与主机之前的关系。</p>
<p>其他主流容器跨主机网络方案：</p>
<p>• Weave</p>
<p>• Calico</p>
<p>• OpenvSwitch</p>
<p><img src="/images/10B81BDFE6B2495FB1B335FAC555BF8Dclipboard.png" alt></p>
<p>1、etcd安装并配置（任意找一台节点安装即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install etcd</span><br><span class="line">vim /etc/etcd/etcd.conf </span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;default&quot;</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line">ss -anpt |grep 2379</span><br></pre></td></tr></table></figure>
<p>2、flanneld安装并配置（两台跨主机的docker主机安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install flannel</span><br><span class="line">vim /etc/sysconfig/flanneld</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=<span class="string">&quot;http://192.168.0.11:2379&quot;</span></span><br><span class="line">FLANNEL_ETCD_PREFIX=<span class="string">&quot;/atomic.io/network&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、向etcd写入子网启动并flanneld服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> <span class="built_in">set</span> /atomic.io/network/config <span class="string">&#x27;&#123; &quot;Network&quot;:&quot;172.17.0.0/16&quot;, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125; &#x27;</span></span><br><span class="line">etcdctl --endpoints=<span class="string">&quot;http://192.168.0.11:2379&quot;</span> get /atomic.io/network/config </span><br><span class="line">systemctl start flanneld.service  </span><br><span class="line">systemctl <span class="built_in">enable</span> flanneld.service </span><br></pre></td></tr></table></figure>
<p>4、配置Docker使用flannel生成的网络信息 (两台跨主机的docker主机配置）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line">EnvironmentFile=/var/run/flannel/docker</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock <span class="variable">$DOCKER_NETWORK_OPTIONS</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker </span><br><span class="line">ps -ef |grep docker</span><br></pre></td></tr></table></figure>
<p>5.两台跨主机的docker主机设置iptable转发策略为允许并重启服务（按顺序启动）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">systemctl restart flanneld.service </span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<p>6、在两台主机创建容器相互ping验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it busybox sh</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure>
<p>防火墙学习：</p>
<p><a href="https://www.cnblogs.com/shijiaqi1066/p/3812510.html">https://www.cnblogs.com/shijiaqi1066/p/3812510.html</a></p>
<p><a href="http://www.zsythink.net/archives/1199">http://www.zsythink.net/archives/1199</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>实际项目部署案例</title>
    <url>/2022/07/16/%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>部署项目前的梳理：</p>
<p>1.项目的代码构成，什么语言开发的</p>
<p>2.项目的依赖环境</p>
<p>3.项目的配置文件在哪里</p>
<p>4.项目的端口清单</p>
<p>5.项目有没有做数据的持久化</p>
<h2 id="容器交付流程">容器交付流程</h2>
<p><img src="/images/7327EAB29F8F4C73A7B379DF9D660DDEclipboard.png" alt></p>
<h2 id="在K8s平台部署项目流程">在K8s平台部署项目流程</h2>
<p><img src="/images/0749CCA49C9444DA9A410901C5F3C4B8clipboard.png" alt></p>
<h2 id="在K8s平台部署Java网站项目">在K8s平台部署Java网站项目</h2>
<p>阿里云maven源地址： <a href="https://maven.aliyun.com/mvn/guide">https://maven.aliyun.com/mvn/guide</a></p>
<p>第一步：制作镜像</p>
<p><img src="/images/1506058D05CA4D20B52B277B065B60ABclipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk maven git -y</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lizhenliang/tomcat-java-demo</span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span> <span class="comment"># 代码编译构建</span></span><br><span class="line">unzip target/*.war -d target/ROOT <span class="comment"># 解压构建文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM lizhenliang/tomcat </span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">RUN <span class="built_in">rm</span> -rf /usr/local/tomcat/webapps/*</span><br><span class="line">COPY target/ROOT /usr/local/tomcat/webapps/ROOT</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t image:tag .</span><br><span class="line">docker push &lt;镜像仓库地址&gt;/&lt;项目名&gt;/image:tag</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d image:tag</span><br></pre></td></tr></table></figure>
<p>使用镜像仓库（私有仓库、公共仓库）：</p>
<p>1、配置可信任（如果仓库是HTTPS访问不用配置）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    insecure-registries<span class="string">&quot;: [&quot;</span>192.168.0.13<span class="string">&quot;]</span></span><br><span class="line"><span class="string">&#125;    </span></span><br></pre></td></tr></table></figure>
<p>2、将镜像仓库认证凭据保存在K8s Secret中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry registry-auth --docker-username=admin --docker-password=Harbor12345 --docker-server=192.168.0.13</span><br></pre></td></tr></table></figure>
<p>3、在yaml中使用这个认证凭据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imagePullSecrets:</span><br><span class="line">- name: registry-auth</span><br></pre></td></tr></table></figure>
<p><img src="/images/06ED566FF1074B42A72AF5B779FE1C3Aclipboard.png" alt></p>
<p>配置认证的的原因是部署的harbor是私有仓库，k8s的每个节点每次去拉取镜像都必须登录harbor仓库，比较麻烦，通过在yaml配置文件指定docker登录认证凭据，这样docker每次部署的时候就会自动去拉取镜像了。</p>
<p>第二步：使用控制器部署镜像</p>
<p><img src="/images/335EB09272114DD3BF1BC4A424A77A7Dclipboard.png" alt></p>
<p><img src="/images/64A3856A336D42DFA7B90B914E97D60Dclipboard.png" alt></p>
<p>注意：在pod中挂载configmap配置文件时，如果指定容器内挂载的目录不是空目录，那么会覆盖原来目录下的内容。</p>
<p>部署configmap</p>
<p>vim configmap.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-config</span><br><span class="line">data:</span><br><span class="line">    application.yml: |</span><br><span class="line">        server:</span><br><span class="line">          port: 8080</span><br><span class="line">        spring:</span><br><span class="line">          datasource:</span><br><span class="line">            url: jdbc:mysql://java-demo-db:3306/k8s?characterEncoding=utf-8</span><br><span class="line">            username: azhe</span><br><span class="line">            password: 123456</span><br><span class="line">            driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">          freemarker:</span><br><span class="line">            allow-request-override: <span class="literal">false</span></span><br><span class="line">            cache: <span class="literal">true</span></span><br><span class="line">            check-template-location: <span class="literal">true</span></span><br><span class="line">            charset: UTF-8</span><br><span class="line">            content-type: text/html; charset=utf-8</span><br><span class="line">            expose-request-attributes: <span class="literal">false</span></span><br><span class="line">            expose-session-attributes: <span class="literal">false</span></span><br><span class="line">            expose-spring-macro-helpers: <span class="literal">false</span></span><br><span class="line">            suffix: .ftl</span><br><span class="line">            template-loader-path:</span><br><span class="line">              - classpath:/templates/</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>部署deployment</p>
<p>vim deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: java</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: java</span><br><span class="line">    spec:</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">      - name: registry-auth</span><br><span class="line">      containers:</span><br><span class="line">      - image: 192.168.0.13/demo/java-demo:v1</span><br><span class="line">        name: java-demo</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.5</span><br><span class="line">            memory: 500Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1</span><br><span class="line">            memory: 1Gi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 40</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: config</span><br><span class="line">          mountPath: <span class="string">&quot;/usr/local/tomcat/webapps/ROOT/WEB-INF/classes/application.yml&quot;</span></span><br><span class="line">          subPath: <span class="string">&quot;application.yml&quot;</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: config</span><br><span class="line">        configMap:</span><br><span class="line">          name: java-demo-config</span><br><span class="line">          items:</span><br><span class="line">          - key: <span class="string">&quot;application.yml&quot;</span></span><br><span class="line">            path: <span class="string">&quot;application.yml&quot;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f configmap.yaml </span><br><span class="line">kubectl apply -f deployment.yaml </span><br></pre></td></tr></table></figure>
<p>第三步：对外暴露应用</p>
<p><img src="/images/CE03F82EDAB4453B93B6E5C1B62E92E4clipboard.png" alt></p>
<p>部署service</p>
<p>vim service.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: java</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署ingress（首先部署nginx-ingress-controller，监听端口是80和443)</p>
<p>vim ingress.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: java.ctnrs.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">        - path: /</span><br><span class="line">          pathType: Prefix</span><br><span class="line">          backend:</span><br><span class="line">            service:</span><br><span class="line">              name: java-demo</span><br><span class="line">              port:</span><br><span class="line">                number: 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>部署mysql数据库（1.部署NFS实现自动创建PV插件 2.导入表到k8s数据库）</p>
<p><a href="/attachments/AD05901F881F482EAC2E9A51FE4E8E13nfs-client.zip">nfs-client.zip</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署NFS实现自动创建PV插件：</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入表到k8s数据库</span></span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl <span class="built_in">cp</span> tables_ly_tomcat.sql java-demo-db-6c775c4d4b-7xfgc:/</span><br><span class="line">kubectl <span class="built_in">exec</span> -it java-demo-db-6c775c4d4b-7xfgc -- bash</span><br><span class="line">mysql -u root -p<span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br><span class="line">show databses;</span><br><span class="line">use k8s;</span><br><span class="line"><span class="built_in">source</span> /tables_ly_tomcat.sql;</span><br></pre></td></tr></table></figure>
<p>vim mysql.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  mysql-root-password: <span class="string">&quot;MTIzNDU2&quot;</span></span><br><span class="line">  mysql-password: <span class="string">&quot;MTIzNDU2&quot;</span></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      project: www</span><br><span class="line">      app: mysql</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: www</span><br><span class="line">        app: mysql</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: db</span><br><span class="line">        image: mysql:5.7.30</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">          limits: </span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 512Mi</span><br><span class="line">        <span class="built_in">env</span>:</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: java-demo-db</span><br><span class="line">              key: mysql-root-password</span><br><span class="line">        - name: MYSQL_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: java-demo-db</span><br><span class="line">              key: mysql-password</span><br><span class="line">        - name: MYSQL_USER</span><br><span class="line">          value: <span class="string">&quot;azhe&quot;</span></span><br><span class="line">        - name: MYSQL_DATABASE</span><br><span class="line">          value: <span class="string">&quot;k8s&quot;</span></span><br><span class="line">        ports:</span><br><span class="line">        - name: mysql</span><br><span class="line">          containerPort: 3306</span><br><span class="line">        livenessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="string">&quot;mysqladmin ping -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          <span class="built_in">exec</span>:</span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="string">&quot;mysqladmin ping -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>&quot;</span></span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: data</span><br><span class="line">          mountPath: /var/lib/mysql</span><br><span class="line">        </span><br><span class="line">      volumes:</span><br><span class="line">      - name: data</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: java-demo-db</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db </span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span></span><br><span class="line">  accessModes:</span><br><span class="line">    - <span class="string">&quot;ReadWriteOnce&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: <span class="string">&quot;8Gi&quot;</span></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: java-demo-db</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">  - name: mysql</span><br><span class="line">    port: 3306</span><br><span class="line">    targetPort: mysql</span><br><span class="line">  selector:</span><br><span class="line">    project: www</span><br><span class="line">    app: mysql </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml </span><br><span class="line">kubectl apply -f ingress.yaml </span><br><span class="line">kubectl apply -f mysql.yaml </span><br></pre></td></tr></table></figure>
<p><a href="http://xn--java-pr9l020c.ctnrs.com">访问java.ctnrs.com</a>，添加用户验证数据库是否可用</p>
<p>第四步：增加公网负载均衡器</p>
<p><img src="/images/FF2962E0EEF647ECBE7499D744E04A67clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream java-demo &#123;</span><br><span class="line">      server 192.168.0.12:80;</span><br><span class="line">      server 192.168.0.13:80;</span><br><span class="line">    &#125;</span><br><span class="line">      server &#123;</span><br><span class="line">         listen 81;</span><br><span class="line">         server_name java.ctnrs.com;</span><br><span class="line">         location / &#123;</span><br><span class="line">            proxy_pass http://java-demo;</span><br><span class="line">            proxy_set_header Host <span class="variable">$Host</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="http://xn--java-pr9l020c.ctnrs.com:81">访问java.ctnrs.com:81</a></p>
<p>1、为指定用户授权访问不同命名空间权限</p>
<p>2、使用Helm完成Java网站项目部署</p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>容器化搭建个人博客系统</title>
    <url>/2022/05/28/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Dockerfile涉及相关的文件及安装包</p>
<p><a href="/attachments/F00C39A38A9E42F1B5B1DB1B3DA7CB4Adockerfile.zip">dockerfile.zip</a></p>
<p><img src="/images/418306A840FE4995A255CA27354E9163clipboard.png" alt></p>
<p>前端项目镜像构建与部署：Nginx</p>
<p>nginx目录文件: 1.Dockerfile 2.nginx-1.15.5.tar.gz 3.nginx.conf4.php.conf</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">LABEL maintainer www.ctnrs.com</span><br><span class="line">RUN yum install -y gcc gcc-c++ make \</span><br><span class="line">    openssl-devel pcre-devel gd-devel \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD nginx-1.15.5.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> nginx-1.15.5 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/nginx \</span><br><span class="line">    --with-http_ssl_module \</span><br><span class="line">    --with-http_stub_status_module &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/nginx/conf/vhost &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf nginx* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/nginx/sbin</span><br><span class="line">COPY nginx.conf /usr/local/nginx/conf/nginx.conf</span><br><span class="line">WORKDIR /usr/local/nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user                 nobody;</span><br><span class="line">worker_processes     4;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log  notice;</span><br><span class="line"></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  4096;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    client_max_body_size         64m;</span><br><span class="line">    include /usr/local/nginx/conf/vhost/*.conf;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        index index.html;</span><br><span class="line">        access_log logs/access.log;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>php.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.ctnrs.com;</span><br><span class="line">    index index.php index.html;</span><br><span class="line"></span><br><span class="line">    access_log logs/www.ctnrs.com_access.log;</span><br><span class="line">    error_log logs/www.ctnrs.com_error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.php$ &#123;</span><br><span class="line">        root /wwwroot;</span><br><span class="line">        fastcgi_pass lnmp_php:9000;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PHP项目镜像构建：PHP</p>
<p>php目录文件: 1.Dockerfile 2.php-5.6.36.tar.gz 3.php-fpm.conf  4.php.ini</p>
<p>Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.ctnrs.com</span><br><span class="line">RUN yum install epel-release -y &amp;&amp; \</span><br><span class="line">    yum install -y gcc gcc-c++ make gd-devel libxml2-devel \</span><br><span class="line">    libcurl-devel libjpeg-devel libpng-devel openssl-devel \</span><br><span class="line">    libmcrypt-devel libxslt-devel libtidy-devel autoconf \</span><br><span class="line">    iproute net-tools telnet wget curl &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    <span class="built_in">rm</span> -rf /var/cache/yum/*</span><br><span class="line"></span><br><span class="line">ADD php-5.6.36.tar.gz /</span><br><span class="line">RUN <span class="built_in">cd</span> php-5.6.36 &amp;&amp; \</span><br><span class="line">    ./configure --prefix=/usr/local/php \</span><br><span class="line">    --with-config-file-path=/usr/local/php/etc \</span><br><span class="line">    --enable-fpm --enable-opcache \</span><br><span class="line">    --with-mysql --with-mysqli --with-pdo-mysql \</span><br><span class="line">    --with-openssl --with-zlib --with-curl --with-gd \</span><br><span class="line">    --with-jpeg-dir --with-png-dir --with-freetype-dir \</span><br><span class="line">    --enable-mbstring --with-mcrypt --enable-hash &amp;&amp; \</span><br><span class="line">    make -j 4 &amp;&amp; make install &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> php.ini-production /usr/local/php/etc/php.ini &amp;&amp; \</span><br><span class="line">    <span class="built_in">cp</span> sapi/fpm/php-fpm.conf /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    sed -i <span class="string">&quot;90a \daemonize = no&quot;</span> /usr/local/php/etc/php-fpm.conf &amp;&amp; \</span><br><span class="line">    <span class="built_in">mkdir</span> /usr/local/php/log &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> / &amp;&amp; <span class="built_in">rm</span> -rf php* &amp;&amp; \</span><br><span class="line">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/local/php/sbin</span><br><span class="line">COPY php.ini /usr/local/php/etc/</span><br><span class="line">COPY php-fpm.conf /usr/local/php/etc/</span><br><span class="line">WORKDIR /usr/local/php</span><br><span class="line">EXPOSE 9000</span><br><span class="line">CMD [<span class="string">&quot;php-fpm&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>容器化搭建个人博客系统</p>
<p>1、自定义网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create lnmp</span><br></pre></td></tr></table></figure>
<p>2、创建Mysql容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_mysql --net lnmp --mount src=mysql-vol,dst=/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=wordpress mysql:5.7 --character-set-server=utf8</span><br></pre></td></tr></table></figure>
<p>3、创建PHP容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_php --net lnmp --mount src=wwwroot,dst=/wwwroot php:v1</span><br></pre></td></tr></table></figure>
<p>4、创建Nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name lnmp_nginx --net lnmp -p 88:80 --mount src=wwwroot,dst=/wwwroot --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=<span class="variable">$PWD</span>/php.conf,dst=/usr/local/nginx/conf/vhost/php.conf nginx:v1</span><br></pre></td></tr></table></figure>
<p>5、访问php网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">vim test.php</span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88/test.php</span><br></pre></td></tr></table></figure>
<p>6.以wordpress博客为例</p>
<p><a href="/attachments/DA30ED5D4B2C4750AEA183252F67A445wordpress-4.9.4-zh_CN.tar.gz">wordpress-4.9.4-zh_CN.tar.gz</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /var/lib/docker/volumes/wwwroot/_data/</span><br><span class="line">tar -zxf wordpress-4.9.4-zh_CN.tar.gz</span><br><span class="line"><span class="built_in">mv</span> wordpress/* .</span><br><span class="line"></span><br><span class="line">http://192.168.0.11:88</span><br></pre></td></tr></table></figure>
<p><img src="/images/691AF1100B69430F9FF94B594939ED9Eclipboard.png" alt></p>
<p><img src="/images/AA9191C1DDFA433D88B7445EB109505Dclipboard.png" alt></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工作负载控制器</title>
    <url>/2022/06/16/%E5%B8%B8%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="工作负载控制器是什么">工作负载控制器是什么</h2>
<p>工作负载控制器（Workload Controllers）是K8s的一个抽象概念，用于更高级层次对象，部署和管理Pod。</p>
<p>常用工作负载控制器：</p>
<ul>
<li>
<p>Deployment ： 无状态应用部署</p>
</li>
<li>
<p>StatefulSet ： 有状态应用部署</p>
</li>
<li>
<p>DaemonSet ： 确保所有Node运行同一个Pod</p>
</li>
<li>
<p>Job ： 一次性任务</p>
</li>
<li>
<p>Cronjob ： 定时任务</p>
</li>
</ul>
<p>控制器的作用：</p>
<ul>
<li>
<p>管理Pod对象</p>
</li>
<li>
<p>使用标签与Pod关联</p>
</li>
<li>
<p>控制器实现了Pod的运维，例如滚动更新、伸缩、副本管理、维护Pod状态等。</p>
</li>
</ul>
<p><img src="/images/57989713257848DF8CDF41CBAA91FBB1clipboard.png" alt></p>
<h2 id="Deployment">Deployment</h2>
<h3 id="Deployment：介绍">Deployment：介绍</h3>
<p>Deployment的功能：</p>
<ul>
<li>
<p>管理Pod和ReplicaSet</p>
</li>
<li>
<p>具有上线部署、副本设定、滚动升级、回滚等功能</p>
</li>
<li>
<p>提供声明式更新，例如只更新一个新的Image 应用场景：网站、API、微服务</p>
</li>
</ul>
<h3 id="Deployment：使用流程">Deployment：使用流程</h3>
<p><img src="/images/7FCAD8175D234694B295C4780BB764D3clipboard.png" alt></p>
<h3 id="Deployment：部署">Deployment：部署</h3>
<p>第一步：部署镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl create deployment web --image=nginx:1.15</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>发布并访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f web-deployment.yaml </span><br><span class="line">kubectl expose deployment web-deployment --port 80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：滚动升级">Deployment：滚动升级</h3>
<p>第二步：应用升级（更新镜像三种方式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml </span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/web nginx=nginx:1.16 </span><br><span class="line">kubectl edit deployment/web</span><br></pre></td></tr></table></figure>
<p>vim web-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 <span class="comment"># Pod副本预期数量</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web <span class="comment"># Pod副本的标签</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: nginx:1.17</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /index.html</span><br><span class="line">            port: 80</span><br><span class="line">          initialDelaySeconds: 10   <span class="comment">#启动容器后多少秒开始检查</span></span><br><span class="line">          periodSeconds: 10      <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/3C61282B9CE64C02BCE02AC6E40E5605clipboard.png" alt></p>
<p>滚动升级：K8s对Pod升级的默认策略，通过使 用新版本Pod逐步更新旧版本Pod，实现零停机 发布，用户无感知。</p>
<p>滚动升级在K8s中的实现：</p>
<ul>
<li>
<p>1个Deployment</p>
</li>
<li>
<p>2个ReplicaSet</p>
</li>
</ul>
<p><img src="/images/9425F7FDCFEE49FE94E6D37E0A26B8C6clipboard.png" alt></p>
<ul>
<li>
<p>maxSurge：滚动更新过程中最大Pod副本数，确保在更新时启动的Pod数 量比期望（replicas）Pod数量最大多出25%</p>
</li>
<li>
<p>maxUnavailable：滚动更新过程中最大不可用Pod副本数，确保在更新时 最大25% Pod数量不可用，即确保75% Pod数量是可用状态。</p>
</li>
</ul>
<p><img src="/images/CD4FE9677984427DA97042EDB93D8695clipboard.png" alt></p>
<h3 id="Deployment：水平扩缩容">Deployment：水平扩缩容</h3>
<p>第三步：水平扩缩容（启动多实例，提高并发）</p>
<ul>
<li>
<p>修改yaml里replicas值，再apply</p>
</li>
<li>
<p>kubectl scale deployment web --replicas=10</p>
</li>
</ul>
<p>注：replicas参数控制Pod副本数量</p>
<p><img src="/images/C5A8BEFC58CA473986D5DBF11B8246F7clipboard.png" alt></p>
<h3 id="Deployment：回滚">Deployment：回滚</h3>
<p>第四步：回滚（发布失败恢复正常版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment/web <span class="comment"># 查看历史发布版本 </span></span><br><span class="line">kubectl rollout undo deployment/web <span class="comment"># 默认回滚上一个版本 </span></span><br><span class="line">kubectl rollout undo deployment/web --to-revision=2 <span class="comment"># 回滚历史指定版本</span></span><br></pre></td></tr></table></figure>
<p>注：回滚是重新部署某一次部署时的状态，即当时版本所有配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deploy web-deployment web=nginx:1.19 --record  <span class="comment">#升级</span></span><br><span class="line">kubectl rollout undo deployment web-deployment --to-revision=7  <span class="comment">#回滚到指定版本</span></span><br><span class="line">kubectl get rs -o wide</span><br><span class="line">kubectl describe rs web-deployment-5449cf89f </span><br></pre></td></tr></table></figure>
<h3 id="Deployment：删除">Deployment：删除</h3>
<p>最后，项目下线：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete deploy/web </span><br><span class="line">kubectl delete svc/web</span><br></pre></td></tr></table></figure>
<h3 id="Deployment：ReplicaSet">Deployment：ReplicaSet</h3>
<p>ReplicaSet控制器用途：</p>
<ul>
<li>
<p>Pod副本数量管理，不断对比当前Pod数量与期望Pod数量</p>
</li>
<li>
<p>Deployment每次发布都会创建一个RS作为记录，用于实现回滚</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get rs <span class="comment">#查看RS记录 </span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment web <span class="comment">#版本对应RS记录</span></span><br><span class="line">kubectl describe rs |egrep -i <span class="string">&quot;revision|image&quot;</span>  <span class="comment">#查看版本对应的镜像</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/F05204D400AC49BD984EC2F32E0FB304clipboard.png" alt></p>
<h2 id="DaemonSet">DaemonSet</h2>
<p>DaemonSet功能：</p>
<ul>
<li>
<p>在每一个Node上运行一个Pod</p>
</li>
<li>
<p>新加入的Node也同样会自动运行一个Pod</p>
</li>
</ul>
<p>应用场景：网络插件（kube-proxy、calico）、其他Agent</p>
<p><img src="/images/8D4FD2F4A8E3450CB224EABA85A1F388clipboard.png" alt></p>
<p>示例：部署一个日志采集程序</p>
<p>vim daemonset.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet        </span><br><span class="line">metadata:</span><br><span class="line">  name: filebeat</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: filebeat</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: filebeat</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:               </span><br><span class="line">      - effect: NoSchedule        <span class="comment">#配置污点容忍，确保分配到每个节点</span></span><br><span class="line">        operator: Exists  <span class="comment">#没有配置键值形式，节点上只要有NoSchedule策略，只要存在就容忍</span></span><br><span class="line">      containers:</span><br><span class="line">      - name: <span class="built_in">log</span></span><br><span class="line">        image: elastic/filebeat:7.3.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f daemonset.yaml </span><br><span class="line">kubectl get daemonsets.apps -n kube-system  <span class="comment">#查看使用daemonset控制器的pod</span></span><br><span class="line">kubectl get daemonsets.apps calico-node -o yaml -n kube-system | grep tor </span><br><span class="line">kubectl get pod -n kube-system -o wide  <span class="comment">#确保在每个节点都启动一个日志采集器pod   </span></span><br></pre></td></tr></table></figure>
<h2 id="Job">Job</h2>
<p>Job分为普通任务（Job）和定时任务（CronJob）</p>
<ul>
<li>一次性执行</li>
</ul>
<p>应用场景：离线数据处理，视频解码等业务</p>
<p>vim job.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: pi</span><br><span class="line">        image: perl</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;perl&quot;</span>, <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(2000)&quot;</span>]</span><br><span class="line">      restartPolicy: Never         <span class="comment">#执行完容器就退出</span></span><br><span class="line">  backoffLimit: 4 <span class="comment"># 重试次数</span></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f job.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get pod    <span class="comment">#complete状态，需要主动删除pod</span></span><br><span class="line">kubectl logs pi-z7rrb </span><br></pre></td></tr></table></figure>
<h2 id="CronJob">CronJob</h2>
<p>CronJob用于实现定时任务，像Linux的Crontab一样。</p>
<ul>
<li>定时任务 应用场景：通知，备份</li>
</ul>
<p>vim cronjob.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: batch/v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">&quot;*/1 * * * *&quot;</span>     <span class="comment">#跟Linux的crontab一样写法</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - name: hello</span><br><span class="line">            image: busybox</span><br><span class="line">            args:</span><br><span class="line">            - /bin/sh</span><br><span class="line">            - -c</span><br><span class="line">            - <span class="built_in">date</span>; <span class="built_in">echo</span> Hello azhe</span><br><span class="line">          restartPolicy: OnFailure   <span class="comment">#如果执行上面的命令失败返回状态码非0会帮你重启容器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f cronjob.yaml </span><br><span class="line">kubectl get job</span><br><span class="line">kubectl get cronjob</span><br><span class="line">kubectl logs hello-1613720220-ldb7z </span><br></pre></td></tr></table></figure>
<p><img src="/images/E705E25E66D840228B054BA469DE8828clipboard.png" alt></p>
<p><img src="/images/8FC4E782A0F040F3A6A2F40F0581134Fclipboard.png" alt></p>
<p><img src="/images/57136FADCE894FA7BF380678271AD152clipboard.png" alt></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>快速部署一个K8s集群</title>
    <url>/2022/06/11/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AAk8s%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="生产环境部署K8s的2种方式">生产环境部署K8s的2种方式</h2>
<h3 id="kubeadm">kubeadm</h3>
<p>Kubeadm是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p>
<p>部署地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
<h3 id="二进制">二进制</h3>
<p>推荐，从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>下载地址：<a href="https://github.com/kubernetes/kubernetes/releases">https://github.com/kubernetes/kubernetes/releases</a></p>
<h2 id="服务器硬件配置推荐">服务器硬件配置推荐</h2>
<p><img src="/images/2AB14DBE37A14CEB9A1838BE07C1D5F5clipboard.png" alt></p>
<h2 id="使用kubeadm快速部署一个K8s集群">使用kubeadm快速部署一个K8s集群</h2>
<table>
<thead>
<tr>
<th>192.168.0.11/24</th>
<th>192.168.0.12/24</th>
<th>192.168.0.13/24</th>
</tr>
</thead>
<tbody>
<tr>
<td>k8s-master</td>
<td>k8s-node1</td>
<td>k8s-node2</td>
</tr>
</tbody>
</table>
<p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 Master 节点</span></span><br><span class="line">$ kubeadm init</span><br><span class="line"><span class="comment"># 将一个 Node 节点加入到当前集群中</span></span><br><span class="line">$ kubeadm <span class="built_in">join</span> &lt;Master节点的IP和端口 &gt;</span><br></pre></td></tr></table></figure>
<p>master：kube-apiserver、scheduler、controller-manager、etcd</p>
<p>node：kubelet（非容器化）、kube-proxy</p>
<p>kubeadm不单纯是简化部署k8s集群，采用了容器化方式部署k8s组件。</p>
<h3 id="1-安装要求">1. 安装要求</h3>
<p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p>
<ul>
<li>
<p>一台或多台机器，操作系统 CentOS7.x-86_x64</p>
</li>
<li>
<p>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</p>
</li>
<li>
<p>集群中所有机器之间网络互通</p>
</li>
<li>
<p>可以访问外网，需要拉取镜像</p>
</li>
<li>
<p>禁止swap分区</p>
</li>
</ul>
<h3 id="2-准备环境">2. 准备环境</h3>
<h4 id="关闭防火墙：">关闭防火墙：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
<h4 id="关闭selinux：">关闭selinux：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久</span></span><br><span class="line">$ setenforce 0  <span class="comment"># 临时</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭swap：">关闭swap：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swapoff -a  <span class="comment"># 临时</span></span><br><span class="line">$ vim /etc/fstab  <span class="comment"># 永久</span></span><br></pre></td></tr></table></figure>
<h4 id="设置主机名：">设置主机名：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hostnamectl set-hostname &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在master添加hosts：">在master添加hosts：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.0.11 k8s-master</span></span><br><span class="line"><span class="string">192.168.0.12 k8s-node1</span></span><br><span class="line"><span class="string">192.168.0.13 k8s-node2</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="将桥接的IPv4流量传递到iptables的链：">将桥接的IPv4流量传递到iptables的链：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ sysctl --system  <span class="comment"># 生效</span></span><br></pre></td></tr></table></figure>
<h4 id="时间同步：">时间同步：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install ntpdate -y</span><br><span class="line">$ ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h3 id="3-安装Docker-kubeadm-kubelet【所有节点】">3. 安装Docker/kubeadm/kubelet【所有节点】</h3>
<p>Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker。</p>
<h4 id="3-1-安装Docker">3.1 安装Docker</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">$ yum -y install docker-ce</span><br><span class="line">$ systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>
<p>配置镜像下载加速器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">$ systemctl restart docker</span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure>
<h4 id="3-2-添加阿里云YUM软件源">3.2 添加阿里云YUM软件源</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-安装kubeadm，kubelet和kubectl">3.3 安装kubeadm，kubelet和kubectl</h4>
<p>由于版本更新频繁，这里指定版本号部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y kubelet-1.19.0 kubeadm-1.19.0 kubectl-1.19.0</span><br><span class="line">$ systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h3 id="4-部署Kubernetes-Master">4. 部署Kubernetes Master</h3>
<p><a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file</a></p>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#initializing-your-control-plane-node</a></p>
<p>在192.168.0.11（Master）执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm init \	</span><br><span class="line">  --apiserver-advertise-address=192.168.0.11 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.19.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">  --ignore-preflight-errors=all</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>–apiserver-advertise-address 集群通告地址</p>
</li>
<li>
<p>–image-repository  由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址</p>
</li>
<li>
<p>–kubernetes-version K8s版本，与上面安装的一致</p>
</li>
<li>
<p>–service-cidr 集群内部虚拟网络，Pod统一访问入口</p>
</li>
<li>
<p>–pod-network-cidr Pod网络，，与下面部署的CNI网络组件yaml中保持一致</p>
</li>
</ul>
<p>kubeadm init初始化工作：</p>
<p>1、[preflight] 环境检查和拉取镜像 kubeadm config /images pull</p>
<p>2、[certs] 生成k8s证书和etcd证书 /etc/kubernetes/pki</p>
<p>3、[kubeconfig] 生成kubeconfig文件</p>
<p>4、[kubelet-start] 生成kubelet配置文件</p>
<p>5、[control-plane] 部署管理节点组件，用镜像启动容器  kubectl get pods -n kube-system</p>
<p>6、[etcd] 部署etcd数据库，用镜像启动容器</p>
<p>7、[upload-config] [kubelet] [upload-certs] 上传配置文件到k8s中</p>
<p>8、[mark-control-plane] 给管理节点添加一个标签 <a href="http://node-role.kubernetes.io/master=">node-role.kubernetes.io/master=</a>‘’，再添加一个污点[<a href="http://node-role.kubernetes.io/master:NoSchedule">node-role.kubernetes.io/master:NoSchedule</a>]</p>
<p>9、[bootstrap-token] 自动为kubelet颁发证书</p>
<p>10、[addons] 部署插件，CoreDNS、kube-proxy</p>
<p>或者使用配置文件引导：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi kubeadm.conf</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.18.0</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers </span><br><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16 </span><br><span class="line">  serviceSubnet: 10.96.0.0/12 </span><br><span class="line">  </span><br><span class="line">$ kubeadm init --config kubeadm.conf --ignore-preflight-errors=all  </span><br></pre></td></tr></table></figure>
<p>拷贝kubectl使用的连接k8s认证文件到默认路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   2m   v1.18.0</span><br></pre></td></tr></table></figure>
<h3 id="5-加入Kubernetes-Node">5. 加入Kubernetes Node</h3>
<p>在192.168.0.11/12（Node）执行。</p>
<p>向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token dq52g0.m44tucwrwwyieklo \</span><br><span class="line">  --discovery-token-ca-cert-hash sha256:0f9df6b112b8bd2ca31c6ccfa777ab057158774bd68990e84393b50e0f181572 </span><br></pre></td></tr></table></figure>
<p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubeadm token create</span><br><span class="line">$ kubeadm token list</span><br><span class="line">$ openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span></span><br><span class="line">63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br><span class="line"></span><br><span class="line">$ kubeadm <span class="built_in">join</span> 192.168.0.11:6443 --token nuja6n.o3jrhsffiqs9swnu --discovery-token-ca-cert-hash sha256:63bca849e0e01691ae14eab449570284f0c3ddeea590f8da988c07fe2729e924</span><br></pre></td></tr></table></figure>
<p>或者直接命令快捷生成：kubeadm token create --print-join-command</p>
<p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/</a></p>
<h3 id="6-部署容器网络（CNI）">6. 部署容器网络（CNI）</h3>
<p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network</a></p>
<p>注意：只需要部署下面其中一个，推荐Calico。</p>
<p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。</p>
<p>Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的虚拟路由器（ vRouter） 来负责数据转发，而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息向整个 Calico 网络内传播。</p>
<p>此外，Calico  项目还实现了 Kubernetes 网络策略，提供ACL功能。</p>
<p><a href="https://docs.projectcalico.org/getting-started/kubernetes/quickstart">https://docs.projectcalico.org/getting-started/kubernetes/quickstart</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure>
<p>下载完后还需要修改里面定义Pod网络（CALICO_IPV4POOL_CIDR），与前面kubeadm init指定的一样</p>
<p>修改完后应用清单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f calico.yaml</span><br><span class="line">$ kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>
<h3 id="7-测试kubernetes集群">7. 测试kubernetes集群</h3>
<ul>
<li>
<p>验证Pod工作</p>
</li>
<li>
<p>验证Pod网络通信</p>
</li>
<li>
<p>验证DNS解析</p>
</li>
</ul>
<p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create deployment nginx --image=nginx</span><br><span class="line">$ kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">$ kubectl get pod,svc</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="http://NodeIP">http://NodeIP</a>:Port</p>
<h3 id="8-部署-Dashboard">8. 部署 Dashboard</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.3/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>
<p>默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi recommended.yaml</span><br><span class="line">...</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">...</span><br><span class="line">$ kubectl apply -f recommended.yaml</span><br><span class="line">$ kubectl get pods -n kubernetes-dashboard</span><br><span class="line">NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">dashboard-metrics-scraper-6b4884c9d5-gl8nr   1/1     Running   0          13m</span><br><span class="line">kubernetes-dashboard-7f99b75bf4-89cds        1/1     Running   0          13m</span><br></pre></td></tr></table></figure>
<p>访问地址：<a href="https://NodeIP:30001">https://NodeIP:30001</a></p>
<p>创建service account并绑定默认cluster-admin管理员集群角色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">$ kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line"><span class="comment"># 用户授权</span></span><br><span class="line">$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line"><span class="comment"># 获取用户Token</span></span><br><span class="line">$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk <span class="string">&#x27;/dashboard-admin/&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用输出的token登录Dashboard。</p>
<p><img src="/images/268C8E2AC7224A1C8F6A0BC88B9B1A0Cclipboard.png" alt></p>
<h2 id="K8s-CNI网络模型">K8s CNI网络模型</h2>
<p><img src="/images/77DF44AB43FB4CA0BA6CEF859FCE5CF3clipboard.png" alt></p>
<p>K8s是一个扁平化网络。</p>
<p>即所有部署的网络组件都必须满足如下要求：</p>
<ul>
<li>
<p>一个Pod一个IP</p>
</li>
<li>
<p>所有的 Pod 可以与任何其他 Pod 直接通信</p>
</li>
<li>
<p>所有节点可以与所有 Pod 直接通信</p>
</li>
<li>
<p>Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个</p>
</li>
</ul>
<p>主流网络组件有：Flannel、Calico等</p>
<h2 id="查看集群状态">查看集群状态</h2>
<h4 id="查看master组件状态：">查看master组件状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs </span><br></pre></td></tr></table></figure>
<h4 id="查看node状态：">查看node状态：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br></pre></td></tr></table></figure>
<h4 id="查看Apiserver代理的URL：">查看Apiserver代理的URL：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info </span><br></pre></td></tr></table></figure>
<h4 id="查看集群详细信息：">查看集群详细信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info dump </span><br></pre></td></tr></table></figure>
<h4 id="查看资源信息：">查看资源信息：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe &lt;资源&gt; &lt;名称&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>数据卷与持久数据卷</title>
    <url>/2022/07/12/%E6%95%B0%E6%8D%AE%E5%8D%B7%E4%B8%8E%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="为什么需要存储卷">为什么需要存储卷</h2>
<p>容器部署过程中一般有以下三种数据：</p>
<ul>
<li>
<p>启动时需要的初始数据，例如配置文件</p>
</li>
<li>
<p>启动过程中产生的临时数据，该临时数据需要多个容器间共享</p>
</li>
<li>
<p>启动过程中产生的持久化数据，例如MySQL的data目录</p>
</li>
</ul>
<p><img src="/images/FB8D2370347643C8B7E7A9D6D7009856clipboard.png" alt></p>
<h2 id="数据卷概述">数据卷概述</h2>
<ul>
<li>
<p>Kubernetes中的Volume提供了在容器中挂载外部存储的能力</p>
</li>
<li>
<p>Pod需要设置卷来源（spec.volume）和挂载点（spec.containers.volumeMounts）两个信息后才可以使用相应的Volume</p>
</li>
</ul>
<p>数据卷类型大致分类：</p>
<ul>
<li>
<p>本地（hostPath，emptyDir等）</p>
</li>
<li>
<p>网络（NFS，Ceph，GlusterFS等）</p>
</li>
<li>
<p>公有云（AWS EBS等）</p>
</li>
<li>
<p>K8S资源（configmap，secret等）</p>
</li>
</ul>
<p>支持的数据劵类型：<a href="https://kubernetes.io/docs/concepts/storage/volumes/">https://kubernetes.io/docs/concepts/storage/volumes/</a></p>
<h2 id="数据卷：emptyDir">数据卷：emptyDir</h2>
<p>emptyDir卷：是一个临时存储卷，与Pod生命周期绑定一起，如果 Pod删除了卷也会被删除。</p>
<p>应用场景：Pod中容器之间数据共享</p>
<p>示例：Pod内容器之前共享数据</p>
<p>vim emptyDir.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: emptydir-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: write</span><br><span class="line">    image: centos</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in &#123;1..100&#125;;do echo <span class="variable">$i</span> &gt;&gt; /data/hello;sleep 1;done&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line">  - name: <span class="built_in">read</span></span><br><span class="line">    image: centos</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /data/hello&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f emptyDir.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl <span class="built_in">exec</span> -it emptydir-pod -c write -- bash   <span class="comment">#写容器</span></span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it emptydir-pod -c <span class="built_in">read</span> -- bash    <span class="comment">#读容器</span></span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line"><span class="comment"># tail -f /data/hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据目录存放在本地的路径</span></span><br><span class="line">kubectl get pod -o wide  <span class="comment">#查看该pod在哪个节点，对应节点查看数据卷目录</span></span><br><span class="line"><span class="comment">#data的存放目录路径</span></span><br><span class="line">docker ps -l         <span class="comment">#查看最近创建的容器</span></span><br><span class="line">/var/lib/kubelet/pods/53d07406-364b-4d85-90b9-e3a6dca15427/volumes/kubernetes.io~empty-dir/data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据卷：hostPath">数据卷：hostPath</h2>
<p>hostPath卷：挂载Node文件系统（Pod所在节点）上文件或者目 录到Pod中的容器。</p>
<p>应用场景：Pod中容器需要访问宿主机文件</p>
<p>示例：将宿主机/tmp目录挂载到容器/data目录</p>
<p>vim hostpath.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostpath-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">sleep</span> 36000</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: data</span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: data</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /tmp</span><br><span class="line">      <span class="built_in">type</span>: Directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f hostpath.yaml </span><br><span class="line">kubectl get pod -o wide     <span class="comment">#查看该pod所在节点</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it hostpath-pod -- sh</span><br><span class="line"><span class="comment"># ls /data/</span></span><br><span class="line"></span><br><span class="line">在pod所在节点的/tmp目录下创建文件，验证pod中/data目录下能否看见</span><br><span class="line"><span class="built_in">touch</span> /tmp/xiaozhe.txt </span><br></pre></td></tr></table></figure>
<h2 id="数据卷：NFS">数据卷：NFS</h2>
<p>NFS数据卷：提供对NFS挂载支持，可以自动将NFS共享 路径挂载到Pod中</p>
<p>NFS：是一个主流的文件共享服务器。</p>
<p><img src="/images/28A0DA7356A64912A77B538BF4AEAF76clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装nfs安装包（每个k8s节点都要安装）</span></span><br><span class="line">yum install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nfs共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /nfs/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改nfs配置文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/kubernetes *(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nfs并加入开机自启</span></span><br><span class="line">systemctl start nfs</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#尝试在别的K8s节点挂载nfs共享目录</span></span><br><span class="line">mount -t nfs 192.168.0.13:/nfs/kubernetes /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment">#在/mnt下新建文件，验证在nfs服务器共享目录下能否看到该文件</span></span><br><span class="line"><span class="built_in">touch</span> /mnt/index.html</span><br><span class="line"><span class="built_in">ls</span> /nfs/kubernetes/</span><br></pre></td></tr></table></figure>
<p>示例：将网站程序通过NFS数据卷共享，让所有Pod使用</p>
<p>vim nfs.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        nfs:</span><br><span class="line">          server: 192.168.0.13</span><br><span class="line">          path: /nfs/kubernetes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nfs.yaml </span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment">#在nfs服务器上修改nfs的共享目录下index.html里面的内容</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt; index.html</span><br><span class="line">curl 10.244.36.74     <span class="comment">#访问nfs的任意pod的IP，验证数据是否共享</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h2 id="持久卷概述">持久卷概述</h2>
<p>PersistentVolume（PV）：对存储资源创建和使用的抽象，使得存储作为集群中的资源管理 • PersistentVolumeClaim（PVC）：让用户不需要关心具体的Volume实现细节</p>
<h2 id="PV与PVC使用流程">PV与PVC使用流程</h2>
<p><img src="/images/FF65698AA4024189919794B4672DE56Bclipboard.png" alt></p>
<p>支持持久卷的存储插件：<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">https://kubernetes.io/docs/concepts/storage/persistent-volumes/</a></p>
<p>vim pv.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim pvc-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pvc-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pvc-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: my-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pvc</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv.yaml </span><br><span class="line">kubectl apply -f pvc-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br><span class="line">kubectl get pod -o wide     </span><br><span class="line">curl 10.244.169.139         <span class="comment">#访问该pod对应的IP</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p><img src="/images/ED2ECD142CBB4EAAB83BC7E2AB52D234clipboard.png" alt></p>
<h2 id="PV-生命周期">PV 生命周期</h2>
<p>ACCESS MODES（访问模式）：</p>
<p>AccessModes 是用来对 PV 进行访问模式的设置，用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>
<p>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</p>
</li>
<li>
<p>ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载</p>
</li>
<li>
<p>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</p>
</li>
</ul>
<p>RECLAIM POLICY（回收策略）：</p>
<p>目前 PV 支持的策略有三种：</p>
<ul>
<li>
<p>Retain（保留）： 保留数据，需要管理员手工清理数据</p>
</li>
<li>
<p>Recycle（回收）：清除 PV 中的数据，效果相当于执行 rm -rf /ifs/kuberneres/*</p>
</li>
<li>
<p>Delete（删除）：与 PV 相连的后端存储同时删除</p>
</li>
</ul>
<p>STATUS（状态）：</p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>
<p>Available（可用）：表示可用状态，还未被任何 PVC 绑定</p>
</li>
<li>
<p>Bound（已绑定）：表示 PV 已经被 PVC 绑定</p>
</li>
<li>
<p>Released（已释放）：PVC 被删除，但是资源还未被集群重新声明</p>
</li>
<li>
<p>Failed（失败）： 表示该 PV 的自动回收失败</p>
</li>
</ul>
<p>现在PV使用方式称为静态供给，需要K8s运维工程师提前创 建一堆PV，供开发者使用。</p>
<p><img src="/images/7F6C904DF2F547EFA22234DA45AC0D74clipboard.png" alt></p>
<p>在nfs服务器共享目录下创建多个目录，供下面引用不同的pv匹配不同的pv目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/</span><br><span class="line"><span class="built_in">mkdir</span> pv&#123;2,3,4&#125;</span><br><span class="line"><span class="built_in">cd</span> pv2/</span><br><span class="line"><span class="built_in">echo</span> 222 &gt;index.html</span><br><span class="line"><span class="built_in">cd</span> ../pv4/</span><br><span class="line"><span class="built_in">echo</span> 444 &gt;index.html    </span><br></pre></td></tr></table></figure>
<p>vim pv234.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 3Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv2</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv3</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv3</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv4</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/kubernetes/pv4</span><br><span class="line">    server: 192.168.0.13</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim pvc234-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: pvc234-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: pvc234-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: pvc234-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: pv2</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: pv2</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 8Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pv234.yaml </span><br><span class="line">kubectl apply -f pvc234-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br></pre></td></tr></table></figure>
<p><img src="/images/4E8E666509E344BB9880A3EE7743CDBCclipboard.png" alt></p>
<p>从上面pvc234-deployment.yaml 文件配置可以看到，配置文件指定的pvc是pv2，使用最大容量是8Gi，但是pv2的容量可以看到是3Gi，并不满足你要使用的容量，但是为了尽可能的分配给你，所以它将pv4指定了给你使用，pv4的容量是10Gi。</p>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide    <span class="comment">#查看该pod对应的IP</span></span><br><span class="line">curl 10.244.36.76        <span class="comment">#可以看到结果是pv4目录下的内容</span></span><br><span class="line">444                      </span><br></pre></td></tr></table></figure>
<h2 id="PV-动态供给（StorageClass）">PV 动态供给（StorageClass）</h2>
<p>PV静态供给明显的缺点是维护成本太高了！</p>
<p>因此，K8s开始支持PV动态供给，使用StorageClass对象实现。</p>
<p><img src="/images/F0D3C44DEBDE478DB81FA77DACA6BD67clipboard.png" alt></p>
<p>支持动态供给的存储插件：<a href="https://kubernetes.io/docs/concepts/storage/storage-classes/">https://kubernetes.io/docs/concepts/storage/storage-classes/</a></p>
<p><img src="/images/4B20627845894BA38107F554AE2F816Eclipboard.png" alt></p>
<p>部署NFS实现自动创建PV插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/external-storage </span><br><span class="line"><span class="built_in">cd</span> nfs-client/deploy </span><br><span class="line">kubectl apply -f rbac.yaml <span class="comment"># 授权访问apiserver </span></span><br><span class="line">kubectl apply -f deployment.yaml <span class="comment"># 部署插件，需修改里面NFS服务器地址与共享目录 </span></span><br><span class="line">kubectl apply -f class.yaml <span class="comment"># 创建存储类</span></span><br><span class="line"></span><br><span class="line">kubectl get sc  <span class="comment"># 查看存储类</span></span><br></pre></td></tr></table></figure>
<p><a href="/attachments/9CF482103C694E018A1FEDFC08B95305nfs-client.zip">nfs-client.zip</a></p>
<p>#修改deployment.yaml 修改里面NFS服务器地址与共享目录</p>
<p><img src="/images/36841FF64E8B43B6BA77621F00E1EAFFclipboard.png" alt></p>
<p>vim sc-deployment.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: sc-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: sc-nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: sc-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wwwroot</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line">      volumes:</span><br><span class="line">      - name: wwwroot</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: nfs-pvc</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-pvc</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: <span class="string">&quot;managed-nfs-storage&quot;</span>  <span class="comment">#在创建pvc时指定存储类名称</span></span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 12Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f sc-deployment.yaml </span><br><span class="line">kubectl get pv,pvc</span><br></pre></td></tr></table></figure>
<p><img src="/images/B5135FE1E30A49D09D5705CF74E0127Dclipboard.png" alt></p>
<p>从上图可以看出当我们使用kubectl创建一个deployment时，它会请求managed-nfs-storage（nfs存储类），然后managed-nfs-storage调用nfs-client-provisioner插件(pod)，帮我们自动创建pv。</p>
<p>访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在nfs服务器共享目录下新建文件</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/default-nfs-pvc-pvc-2a62f7d8-b356-45d0-87cb-018c10447595</span><br><span class="line"><span class="built_in">echo</span> sc &gt; index.html</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.169.142      <span class="comment">#验证数据是否是新建的内容</span></span><br><span class="line">sc</span><br></pre></td></tr></table></figure>
<p>删除deployment</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f sc-deployment.yaml</span><br></pre></td></tr></table></figure>
<p>在nfs服务器上的共享目录查看</p>
<p><img src="/images/B45261F8AE7B4F79815693DABBBC1544clipboard.png" alt></p>
<p><img src="/images/EF34312BE1134B1CA0B0D557B9299951clipboard.png" alt></p>
<p><img src="/images/F8A5A52C50774ACE84922233ED73CF99clipboard.png" alt></p>
<p>从上面可以看出，nfs的回收策略是deployment删除后端的存储也同时删除，但是当我们把deployment删除之后，数据共享目录还在，并没有删除，它只是帮我们把数据共享目录归档了，如果要删除需要修改class.yaml 配置文件中的archiveOnDelete为false，这时就会帮我们删除后端数据共享目录。</p>
<p><img src="/images/CEA08EB09CA34E518ABCAD947DE16DA3clipboard.png" alt></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f class.yaml  <span class="comment">#更新配置</span></span><br><span class="line">kubectl delete -f sc-deployment.yaml   </span><br><span class="line">kubectl apply -f sc-deployment.yaml    <span class="comment">#删除再创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再次在nfs服务器共享目录下新建文件</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/kubernetes/default-nfs-pvc-pvc-d5ca3b6e-7045-4868-8fdf-17063bc19e13</span><br><span class="line"><span class="built_in">echo</span> 123456 &gt; index.html</span><br><span class="line">kubectl get pod -o wide</span><br><span class="line">curl 10.244.169.142      <span class="comment">#验证数据是否是新建的内容</span></span><br><span class="line">123456</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除deployment后，验证在nfs服务器上查看是否删除了数据共享目录下的pv目录</span></span><br><span class="line">kubectl delete -f sc-deployment.yaml  </span><br></pre></td></tr></table></figure>
<p>Q：PV与PVC什么关系？</p>
<p>A：一对一</p>
<p>Q：PVC与PV怎么匹配的？</p>
<p>A：访问模式和存储容量</p>
<p>Q：容量匹配策略</p>
<p>A：匹配就近的符合的容量（向上）</p>
<p>Q：存储容量是真的用于限制吗？</p>
<p>A：存储容量取决于后端存储，容量字段主要还是用于匹配</p>
<p>1、使用Ingress暴露应用对外访问</p>
<p>2、创建一个configmap，使用环境变量和数据卷方式引用</p>
<p>3、创建一个pv，再创建一个pod使用该pv</p>
<p>4、配置PV自动供给，再创建一个pod使用该pv</p>
<p>注：自由发挥，实现需求即可</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：基本管理</title>
    <url>/2022/06/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3pod%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Pod基本概念">Pod基本概念</h2>
<p>Pod是Kubernetes创建和管理的最小单元，一个Pod由一个容器 或多个容器组成，这些容器共享存储、网络。</p>
<p><img src="/images/3E268FAA2D524894BEC9CE7602E5ACDFclipboard.png" alt></p>
<p>Pod特点：</p>
<ul>
<li>
<p>一个Pod可以理解为是一个应用实例，提供服务</p>
</li>
<li>
<p>Pod中容器始终部署在一个Node上</p>
</li>
<li>
<p>Pod中容器共享网络、存储资源</p>
</li>
<li>
<p>Kubernetes直接管理Pod，而不是容器</p>
</li>
</ul>
<h2 id="Pod存在的意义">Pod存在的意义</h2>
<p>Pod主要用法：</p>
<ul>
<li>
<p>运行单个容器：最常见的用法，在这种情况下，可以将Pod看做是单个容器的抽象封装</p>
</li>
<li>
<p>运行多个容器：封装多个紧密耦合且需要共享资源的应用程序</p>
</li>
</ul>
<p>如果有这些需求，你可以运行多个容器：</p>
<ul>
<li>
<p>两个应用之间发生文件交互</p>
</li>
<li>
<p>两个应用需要通过127.0.0.1或者socket通信</p>
</li>
<li>
<p>两个应用需要发生频繁的调用</p>
</li>
</ul>
<h2 id="Pod资源共享实现机制">Pod资源共享实现机制</h2>
<p><img src="/images/615C60882D224E8DB8C6C12AAD1DB9CEclipboard.png" alt></p>
<p>共享网络：将业务容器网络加入到“负责网络的容器”实现网络共享</p>
<p>测试验证是否共享网络：</p>
<p>vim pod-net.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: <span class="built_in">test</span></span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-net.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod -c <span class="built_in">test</span> -- sh   <span class="comment">#进入tets容器验证是否能访问nginx</span></span><br><span class="line">wget 127.0.0.1:80 </span><br><span class="line"><span class="built_in">cat</span> index.html      </span><br></pre></td></tr></table></figure>
<p><img src="/images/83663818D7C24666AB6C087931A7E27Bclipboard.png" alt></p>
<p>共享存储：容器通过数据卷共享数据</p>
<p>测试验证是否共享存储：</p>
<p>vim pod-vol.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web2</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  - name: test2</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;sleep 360000&quot;</span>]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: <span class="built_in">log</span></span><br><span class="line">      mountPath: /data</span><br><span class="line"></span><br><span class="line">  volumes:</span><br><span class="line">  - name: <span class="built_in">log</span></span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-vol.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c test2 -- sh     <span class="comment">#进入test容器在/data目录下创建文件</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">touch</span> 1.txt</span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod2 -c web2 -- bash   <span class="comment">#进入web2容器/data目录下查看是否有1.txt</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h2 id="Pod管理命令">Pod管理命令</h2>
<p>创建Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod.yaml </span><br><span class="line">或者使用命令 kubectl run nginx --image=nginx </span><br></pre></td></tr></table></figure>
<p>查看Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods </span><br><span class="line">kubectl describe pod &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p>查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] </span><br><span class="line">kubectl logs &lt;pod名称&gt; [-c CONTAINER] -f </span><br></pre></td></tr></table></figure>
<p>进入容器终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> &lt;pod名称&gt; [-c CONTAINER] -- bash </span><br></pre></td></tr></table></figure>
<p>删除Pod：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/D3AF0D4278F7416FA89311678BF55FBDclipboard.png" alt></p>
<h2 id="重启策略-健康检查（应用自修复）">重启策略+健康检查（应用自修复）</h2>
<p><img src="/images/61383041DB4F45189A6A194539803642clipboard.png" alt></p>
<p>重启策略：</p>
<ul>
<li>
<p>Always：当容器终止退出后，总是重启容器，默认策略。</p>
</li>
<li>
<p>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</p>
</li>
<li>
<p>Never：当容器终止退出，从不重启容器</p>
</li>
</ul>
<p>健康检查有以下两种类型：</p>
<ul>
<li>
<p>livenessProbe（存活检查）：如果检查失败，将杀死容器，根据Pod 的restartPolicy来操	    作。</p>
</li>
<li>
<p>readinessProbe（就绪检查）：如果检查失败，Kubernetes会把 Pod从service endpoints中剔除。</p>
</li>
<li>
<p>startupProbe（启动检查）：</p>
</li>
</ul>
<p>支持以下三种检查方法：</p>
<ul>
<li>
<p>httpGet：发送HTTP请求，返回200-400范围状态码为成功。</p>
</li>
<li>
<p>exec：执行Shell命令返回状态码是0为成功。</p>
</li>
<li>
<p>tcpSocket：发起TCP Socket建立成功</p>
</li>
</ul>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></p>
<p>测试验证：</p>
<p>vim pod-check.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    <span class="built_in">test</span>: liveness</span><br><span class="line">  name: pod-check</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">touch</span> /tmp/healthy; <span class="built_in">sleep</span> 30; <span class="built_in">rm</span> -rf /tmp/healthy; <span class="built_in">sleep</span> 600</span><br><span class="line">    livenessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br><span class="line">    readinessProbe:</span><br><span class="line">      <span class="built_in">exec</span>:</span><br><span class="line">        <span class="built_in">command</span>:</span><br><span class="line">        - <span class="built_in">cat</span></span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5     <span class="comment">##启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 5           <span class="comment">##以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-check.yaml</span><br><span class="line">kubectl expose pod pod-check --port 80 --target-port=80</span><br><span class="line">kubectl get pod -w           <span class="comment">#实时验证pod的重启次数是否增加</span></span><br><span class="line">kubectl get endpoints -w     <span class="comment">#实时验证pod是否被service剔除</span></span><br><span class="line">kubectl describe pod pod-check  <span class="comment">#查看pod的变化信息</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/619AB9E4410C495098F4F286EC63B2FBclipboard.png" alt></p>
<p><img src="/images/3D917C45F9F8485CBA8164C9A519E60Bclipboard.png" alt></p>
<p>示例：端口探测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: probe-demo</span><br><span class="line">  namespace: demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    readinessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /</span><br><span class="line">        port: 80</span><br><span class="line">      initialDelaySeconds: 30 <span class="comment">#启动容器后多少秒健康检查</span></span><br><span class="line">      periodSeconds: 10 <span class="comment">#以后间隔多少秒检查一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：livenessProbe与readinessProbe配置一样。</p>
<p>示例：执行Shell命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  <span class="built_in">exec</span>:</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - <span class="built_in">cat</span></span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure>
<p>示例：HTTP请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure>
<h2 id="环境变量">环境变量</h2>
<p>变量值几种定义方式：</p>
<ul>
<li>
<p>自定义变量值</p>
</li>
<li>
<p>变量值从Pod属性获取</p>
</li>
<li>
<p>变量值从Secret、ConfigMap获取</p>
</li>
</ul>
<p>示例</p>
<p>vim pod-var.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-envars</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: <span class="built_in">test</span></span><br><span class="line">      image: busybox</span><br><span class="line">      <span class="built_in">command</span>: [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 36000&quot;</span>]</span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">      - name: MY_NODE_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: spec.nodeName</span><br><span class="line">      - name: MY_POD_NAME</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.name</span><br><span class="line">      - name: MY_POD_NAMESPACE</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: metadata.namespace</span><br><span class="line">      - name: MY_POD_IP</span><br><span class="line">        valueFrom:</span><br><span class="line">          fieldRef:</span><br><span class="line">            fieldPath: status.podIP</span><br><span class="line">      - name: ABC</span><br><span class="line">        value: <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-var.yaml </span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-envars -- sh</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/4DA5F5128F174CD0BDF4FD1B2B0EF9C0clipboard.png" alt></p>
<h2 id="Init-Container">Init Container</h2>
<p>Init Container：顾名思义，用于初始化工作，执行完就结束，可以理解为一次性任务。</p>
<ul>
<li>
<p>支持大部分应用容器配置，但不支持健康检查</p>
</li>
<li>
<p>优先应用容器执行</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>环境检查：例如确保应用容器依赖的服务启动后再启动应用容器</p>
</li>
<li>
<p>初始化配置：例如给应用容器准备配置文件</p>
</li>
</ul>
<p>示例：</p>
<p>部署一个web网站，网站程序没有打到镜像中，而是希望从代码 仓库中动态拉取放到应用容器中。</p>
<p>vim pod-init.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: download</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - wget</span><br><span class="line">    - <span class="string">&quot;-O&quot;</span></span><br><span class="line">    - <span class="string">&quot;/opt/index.html&quot;</span></span><br><span class="line">    - http://www.ctnrs.com</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: <span class="string">&quot;/opt&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: wwwroot</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  volumes:</span><br><span class="line">  - name: wwwroot</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-init.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod init-demo </span><br><span class="line">kubectl <span class="built_in">exec</span> -it init-demo -- bash</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<p><img src="/images/3A5212D0E7FE4E829F051C6E3F7E4136clipboard.png" alt></p>
<p>因此，Pod中会有这几种类型的容器：</p>
<p>Infrastructure Container：基础容器</p>
<p>维护整个Pod网络空间</p>
<p>InitContainers：初始化容器</p>
<p>先于业务容器开始执行</p>
<p>Containers：业务容器</p>
<p>并行启动</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Pod对象：调度</title>
    <url>/2022/06/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3pod%E5%AF%B9%E8%B1%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="创建一个Pod的工作流程">创建一个Pod的工作流程</h2>
<p>Kubernetes基于list-watch机制的控制器架构，实现组件间交 互的解耦。 其他组件监控自己负责的资源，当这些资源发生变化时，kubeapiserver会通知这些组件，这个过程类似于发布与订阅。</p>
<p><img src="/images/D8794DF48C0F4816BA54E7FA97CDBB36clipboard.png" alt></p>
<h2 id="Pod中影响调度的主要属性">Pod中影响调度的主要属性</h2>
<p><img src="/images/8AF33B3162AB4F3D882A6D2D180DC683clipboard.png" alt></p>
<h2 id="资源限制对Pod调度的影响">资源限制对Pod调度的影响</h2>
<p>容器资源限制：</p>
<ul>
<li>
<p>resources.limits.cpu</p>
</li>
<li>
<p>resources.limits.memory</p>
</li>
</ul>
<p>容器使用的最小资源需求，作为容器调度时资 源分配的依据：</p>
<ul>
<li>
<p>resources.requests.cpu</p>
</li>
<li>
<p>resources.requests.memory</p>
</li>
</ul>
<p>CPU单位：可以写m也可以写浮点数，例如0.5=500m，1=1000m</p>
<p><img src="/images/221BA88F1B514916BB8177EFC3777F22clipboard.png" alt></p>
<p>K8s会根据Request的值去查找有足够资源的Node来调度此Pod</p>
<p>vim pod-resources.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-resources</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:             <span class="comment">#容器最小资源配额</span></span><br><span class="line">        memory: <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;250m&quot;</span></span><br><span class="line">      limits:               <span class="comment">#容器最大资源上限</span></span><br><span class="line">        memory: <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        cpu: <span class="string">&quot;500m&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-resources.yaml </span><br><span class="line">kubectl describe pod pod-resources </span><br><span class="line">kubectl describe nodes  k8s-node1</span><br><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<h2 id="nodeSelector-nodeAffinity">nodeSelector &amp; nodeAffinity</h2>
<p>nodeSelector：用于将Pod调度到匹配Label的Node上，如果没有匹配的标签会调度失败。</p>
<p>作用：</p>
<ul>
<li>
<p>约束Pod到特定的节点运行</p>
</li>
<li>
<p>完全匹配节点标签</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU</p>
</li>
</ul>
<p>示例：确保Pod分配到具有SSD硬盘的节点上</p>
<p>第一步：给节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br><span class="line">例如：kubectl label nodes k8s-node1 disktype=ssd</span><br><span class="line">验证：kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure>
<p><img src="/images/A8DD05B47B464360BC6A4C9562D81BBBclipboard.png" alt></p>
<p>第二步：添加nodeSelector字段到Pod配置中</p>
<p>vim pod-selector.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: <span class="string">&quot;ssd&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector.yaml </span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>
<p><img src="/images/5B3E454BCE9B4228A079570CF0D7D7F0clipboard.png" alt></p>
<p>示例：使Pod分配到gpu是NVIDIA的节点上，k8s节点中并没有这个标签的节点</p>
<p>vim pod-selector2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-selector2</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: <span class="string">&quot;NVIDIA&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-selector2.yaml </span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-selector2 </span><br></pre></td></tr></table></figure>
<p><img src="/images/825563AE4A8E4FB1A54BDE56BAB0FCA0clipboard.png" alt></p>
<p><img src="/images/AE756360AFBA4009A26073FD733BC33Aclipboard.png" alt></p>
<p>nodeAffinity：节点亲和性，与nodeSelector作用一样，但相比 更灵活，满足更多条件，诸如：</p>
<ul>
<li>
<p>匹配有更多的逻辑组合，不只是字符串的完全相等</p>
</li>
<li>
<p>调度分为软策略和硬策略，而不是硬性要求</p>
</li>
<li>
<p>硬（required）：必须满足</p>
</li>
<li>
<p>软（preferred）：尝试满足，但不保证</p>
</li>
</ul>
<p>操作符：In、NotIn、Exists、DoesNotExist、Gt、Lt</p>
<p>示例：在pod满足硬性标签要求的前提下，如果没有满足其他的标签，则在满足硬性标签要求的机器上随机调度分配一台</p>
<p>vim pod-affinity.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-node-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: gpu</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - nvidia-tesla</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: group</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - ai</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod-affinity.yaml</span><br><span class="line">kubectl get pod </span><br><span class="line">kubectl describe pod pod-node-affinity </span><br></pre></td></tr></table></figure>
<p><img src="/images/095D6E3DA6D04C2192B2F95B272255D5clipboard.png" alt></p>
<p>验证：</p>
<p>1.如果两个节点都满足硬性标签要求，其中一个节点也满足软性标签要求，那么会优先分配到这个节点。</p>
<p>2.如果两个节点都满足硬性标签要求，都没有满足软性标签要求，那么会随机调度到其中的一个节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给节点添加标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt; </span><br><span class="line">例如：kubectl label node 192.168.1.205 mem=large</span><br><span class="line"><span class="comment">#给节点删除标签的命令</span></span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;-</span><br><span class="line">例如：kubectl label node 192.168.1.205 mem-</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Taint（污点）与Tolerations（污点容忍）">Taint（污点）与Tolerations（污点容忍）</h2>
<p>Taints：避免Pod调度到特定Node上</p>
<p>Tolerations：允许Pod调度到持有Taints的Node上</p>
<p>应用场景：</p>
<ul>
<li>
<p>专用节点：根据业务线将Node分组管理，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>配备特殊硬件：部分Node配有SSD硬盘、GPU，希望在默认情况下不调度该节点，只有配置了污点容忍才允许分配</p>
</li>
<li>
<p>基于Taint的驱逐</p>
</li>
</ul>
<p>第一步：给节点添加污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：kubectl taint node [node] key=value:[effect] </span><br><span class="line">例如：kubectl taint node k8s-node1 gpu=<span class="built_in">yes</span>:NoSchedule </span><br><span class="line">验证：kubectl describe node k8s-node1 |grep Taint</span><br></pre></td></tr></table></figure>
<p>其中[effect] 可取值：</p>
<ul>
<li>
<p>NoSchedule ：一定不能被调度</p>
</li>
<li>
<p>PreferNoSchedule：尽量不要调度，非必须配置容忍</p>
</li>
<li>
<p>NoExecute：不仅不会调度，还会驱逐Node上已有的Pod</p>
</li>
</ul>
<p>第二步：添加污点容忍（tolrations）字段到Pod配置中</p>
<p><img src="/images/6D0B55F924AC4E66A1BBBEEB2457C77Cclipboard.png" alt></p>
<p>去掉污点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key:[effect]-</span><br></pre></td></tr></table></figure>
<p>示例一</p>
<p>1.给node节点添加标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label nodes k8s-node1 gpu=iniaid</span><br><span class="line">kubectl label nodes k8s-node2 disktype=ssd</span><br><span class="line">kubectl get nodes --show-labels </span><br><span class="line">kubectl taint node |grep Taint</span><br></pre></td></tr></table></figure>
<p>2.给node1节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node1 gpu=iniaid:NoSchedule</span><br></pre></td></tr></table></figure>
<p>3.新建pod2.yaml文件并启动pod</p>
<p>vim pod2.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod2</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>4.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod2.yaml </span><br><span class="line">kubectl get pod -o wide  <span class="comment">#观察pod2是否被调度到node2节点上</span></span><br></pre></td></tr></table></figure>
<p>示例二</p>
<p>1.基于示例一，给node2节点配置污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node k8s-node2 disktype=ssd:NoSchedule</span><br></pre></td></tr></table></figure>
<p>2.新建pod3.yaml文件并启动pod</p>
<p>vim pod3.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod3</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>3.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod3.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#查看pod3是否处于pending状态</span></span><br><span class="line">kubectl describe pod pod3    <span class="comment">#查看pod3的状态</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/5E8FF7CD88DC4C12AF574509137E2137clipboard.png" alt></p>
<p>上面的意思是默认计划程序0/3个节点可用：1个节点有污点{disktype:ssd}，pod不能容忍，1个节点有污点{gpu:iniaid}，pod不能容忍，1个节点有污点{node}-role.kubernetes.io/主。</p>
<p>示例三</p>
<p>1.基于示例二，添加污点容忍使pod能够分配到node1节点上</p>
<p>vim pod4.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod4</span><br><span class="line">spec:</span><br><span class="line">  tolerations:                  <span class="comment">#意思是分配到标签gpu=iniaid的这个节点上</span></span><br><span class="line">  - key: <span class="string">&quot;gpu&quot;</span>                   </span><br><span class="line">    operator: <span class="string">&quot;Equal&quot;</span>           <span class="comment">#操作符等于的意思</span></span><br><span class="line">    value: <span class="string">&quot;iniaid&quot;</span></span><br><span class="line">    effect: <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加上effect: &quot;NoSchedule&quot;的意思：更精确一点，如果不加的话，比如两个节点都有gpu=iniaid这个标签，但它们的effect的调度策略不同，那么pod可能会分配到这两个节点上。</p>
<p>2.验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod4.yaml </span><br><span class="line">kubectl get pod  -o wide   <span class="comment">#验证是否被分配到node1节点上</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/982EB5703C1E487E9146B059C6435868clipboard.png" alt></p>
<p>最后去掉污点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe nodes |grep Taint   <span class="comment">#查看当前有污点的节点</span></span><br><span class="line">kubectl taint node k8s-nod2 disktype-    <span class="comment">#去掉node1节点的污点</span></span><br><span class="line">kubectl taint node k8s-node2 disktype-   <span class="comment">#去掉node2节点的污点</span></span><br><span class="line">kubectl describe nodes |grep Taint      <span class="comment">#验证是否去掉了污点</span></span><br></pre></td></tr></table></figure>
<p>验证pod3是否被调度成功</p>
<p><img src="/images/4978D9F6F11F4C1987D9EC08C3E68324clipboard.png" alt></p>
<h2 id="nodeName">nodeName</h2>
<p>nodeName：指定节点名称，用于将Pod调度到指定的Node上，不经过调度器</p>
<p>示例：将pod指定到有污点的节点上</p>
<p>vim pod5.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod5</span><br><span class="line">spec:</span><br><span class="line">  nodeName: k8s-node2</span><br><span class="line">  containers:</span><br><span class="line">  - name: web</span><br><span class="line">    image: nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod5.yaml </span><br><span class="line">kubectl get pod   <span class="comment">#可以看到pod成功运行，因为它不经过调度器</span></span><br></pre></td></tr></table></figure>
<p>适用于调度器故障的时候，可以手动指定分配pod到某个节点上，很少使用。</p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>管理应用程序配置</title>
    <url>/2022/07/11/%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="ConfigMap">ConfigMap</h2>
<p>创建ConfigMap后，数据实际会存储在K8s中Etcd，然后通过创建Pod时引用该数据。</p>
<p>应用场景：应用程序配置</p>
<p>Pod使用configmap数据有两种方式：</p>
<ul>
<li>
<p>变量注入</p>
</li>
<li>
<p>数据卷挂载</p>
</li>
</ul>
<p>两种数据类型：</p>
<ul>
<li>
<p>键值</p>
</li>
<li>
<p>多行数据</p>
</li>
</ul>
<p>#解释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  <span class="comment">#pod的名字</span></span><br><span class="line">  name: configmap-demo-pod   </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: demo</span><br><span class="line">      image: alpine</span><br><span class="line">      <span class="comment">#用进程夯筑容器不让它退出</span></span><br><span class="line">      <span class="built_in">command</span>: [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]   </span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">        <span class="comment"># 定义环境变量</span></span><br><span class="line">        <span class="comment"># 请注意这里和 ConfigMap中的键名是不一样的（自定义键的名字）</span></span><br><span class="line">        - name: ABC </span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              <span class="comment"># 这个值来自 ConfigMa(comfigmap的名字)</span></span><br><span class="line">              name: configmap-demo     </span><br><span class="line">              <span class="comment"># 需要取值的键          </span></span><br><span class="line">              key: abc                       </span><br><span class="line">        - name: CDE</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: cde</span><br><span class="line">      volumeMounts:</span><br><span class="line">      <span class="comment">#引用下面数据卷的名字</span></span><br><span class="line">      - name: config     </span><br><span class="line">        <span class="comment">#挂载到容器中哪个目录下（一般是指你的应用程序配置文件存放目录）</span></span><br><span class="line">        mountPath: <span class="string">&quot;/config&quot;</span>            </span><br><span class="line">        readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">    <span class="comment"># 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中</span></span><br><span class="line">    - name: config     <span class="comment">#数据卷的名字</span></span><br><span class="line">      configMap:</span><br><span class="line">        <span class="comment"># 提供你想要挂载的 ConfigMap 的名字</span></span><br><span class="line">        name: configmap-demo</span><br><span class="line">        <span class="comment"># 来自 ConfigMap 的一组键，将被创建为文件</span></span><br><span class="line">        items:</span><br><span class="line">        - key: <span class="string">&quot;redis.properties&quot;</span>     </span><br><span class="line">          path: <span class="string">&quot;redis.properties&quot;</span>   <span class="comment">#挂载到/config目录下的文件名</span></span><br></pre></td></tr></table></figure>
<p>vim configmap.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: configmap-demo</span><br><span class="line">data:</span><br><span class="line">  abc: <span class="string">&quot;123&quot;</span></span><br><span class="line">  cde: <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line">  redis.properties: |</span><br><span class="line">    port: 6379</span><br><span class="line">    host: 192.168.0.11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim configmap-demo-pod.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: configmap-demo-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: demo</span><br><span class="line">      image: nginx</span><br><span class="line">      <span class="built_in">env</span>:</span><br><span class="line">        - name: ABC</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: abc</span><br><span class="line">        - name: CDE</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: configmap-demo</span><br><span class="line">              key: cde</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: config</span><br><span class="line">        mountPath: <span class="string">&quot;/config&quot;</span></span><br><span class="line">        readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">    - name: config</span><br><span class="line">      configMap:</span><br><span class="line">        name: configmap-demo</span><br><span class="line">        items:</span><br><span class="line">        - key: <span class="string">&quot;redis.properties&quot;</span></span><br><span class="line">          path: <span class="string">&quot;redis.properties&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f configmap.yaml</span><br><span class="line">kubectl apply -f configmap-demo-pod.yaml </span><br><span class="line">kubectl get configmaps </span><br><span class="line">kubectl <span class="built_in">exec</span> -it configmap-demo-pod -- bash   <span class="comment">#进入pod中测试是否注入变量和挂载</span></span><br><span class="line"><span class="comment">#echo $ABC</span></span><br><span class="line"><span class="comment">#echo $CDE</span></span><br><span class="line"><span class="comment">#ls /config/   </span></span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/">https://kubernetes.io/zh/docs/concepts/configuration/configmap/</a></p>
<h2 id="Secret">Secret</h2>
<p>与ConfigMap类似，区别在于Secret主要存储敏感数据，所有的数据要经过base64编码。</p>
<p>应用场景：凭据</p>
<p>kubectl create secret 支持三种数据类型：</p>
<ul>
<li>
<p>docker-registry（<a href="http://kubernetes.io/dockerconfigjson%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF">kubernetes.io/dockerconfigjson）：存储镜像仓库认证信息</a></p>
</li>
<li>
<p>generic（Opaque）：存储密码、密钥等</p>
</li>
<li>
<p>tls（<a href="http://kubernetes.io/tls%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8TLS%E8%AF%81%E4%B9%A6">kubernetes.io/tls）：存储TLS证书</a></p>
</li>
</ul>
<p>Pod使用Secret数据与ConfigMap方式一样。</p>
<p>第一步：将用户名密码进行编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]<span class="comment"># echo -n &#x27;admin&#x27; |base64 </span></span><br><span class="line">YWRtaW4=</span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># echo -n &#x27;123.com&#x27; |base64 </span></span><br><span class="line">MTIzLmNvbQ==</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二步：将编码后值放到Secret</p>
<p>vim secret.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: db-user-pass</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">  password: MTIzLmNvbQ==</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim secret-demo-pod.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-demo-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: demo</span><br><span class="line">    image: nginx</span><br><span class="line">    <span class="built_in">env</span>:</span><br><span class="line">    - name: USER</span><br><span class="line">      valueFrom:</span><br><span class="line">        secretKeyRef:</span><br><span class="line">          name: db-user-pass</span><br><span class="line">          key: username</span><br><span class="line">    - name: PASS</span><br><span class="line">      valueFrom:</span><br><span class="line">        secretKeyRef:</span><br><span class="line">          name: db-user-pass</span><br><span class="line">          key: password</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: config</span><br><span class="line">      mountPath: <span class="string">&quot;/config&quot;</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: config</span><br><span class="line">    secret:</span><br><span class="line">      secretName: db-user-pass</span><br><span class="line">      items:</span><br><span class="line">      - key: username</span><br><span class="line">        path: my-username</span><br><span class="line">      - key: password</span><br><span class="line">        path: my-password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>验证查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f secret.yaml </span><br><span class="line">kubectl apply -f secret-demo-pod.yaml </span><br><span class="line">kubectl get secrets </span><br><span class="line">kubectl <span class="built_in">exec</span> -it secret-demo-pod -- bash     <span class="comment">#进入pod中测试是否注入变量和挂载</span></span><br><span class="line"><span class="comment">#echo $USER</span></span><br><span class="line"><span class="comment">#echo $PASS </span></span><br><span class="line"><span class="comment">#ls /config/</span></span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/">https://kubernetes.io/zh/docs/concepts/configuration/secret/</a></p>
<h2 id="应用程序如何动态更新配置">应用程序如何动态更新配置</h2>
<p>应用程序动态更新配置方案：</p>
<ul>
<li>
<p>当ConfigMap发生变更时，应用程序自动感知动态加载（需要程序自身支持）</p>
</li>
<li>
<p>触发滚动更新，即重启服务</p>
</li>
</ul>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>资源编排（YAML）</title>
    <url>/2022/06/13/%E8%B5%84%E6%BA%90%E7%BC%96%E6%8E%92/</url>
    <content><![CDATA[<h2 id="YAML文件格式说明">YAML文件格式说明</h2>
<p>K8s是一个容器编排引擎，使用YAML文件编排要部署应用，因此在学习之前，应先了解YAML语法格式：</p>
<ul>
<li>
<p>缩进表示层级关系</p>
</li>
<li>
<p>不支持制表符“tab”缩进，使用空格缩进</p>
</li>
<li>
<p>通常开头缩进 2 个空格</p>
</li>
<li>
<p>字符后缩进 1 个空格，如冒号、逗号等</p>
</li>
<li>
<p>“—” 表示YAML格式，一个文件的开始</p>
</li>
<li>
<p>“#”注释</p>
</li>
</ul>
<h2 id="YAML文件创建资源对象">YAML文件创建资源对象</h2>
<p><img src="/images/DDD11D0D0D92486CBFCC20771E6BA98Dclipboard.png" alt></p>
<p>等同于：kubectl create deployment web --image=lizhenliang/java-demo -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: web</span><br><span class="line">        image: lizhenliang/java-demo</span><br></pre></td></tr></table></figure>
<p><img src="/images/5F75CF2C8465417682F5B254CD102040clipboard.png" alt></p>
<p>等同于：kubectl expose deployment web --port=80 --target-port=8080 --type=NodePort -n default</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: web</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br></pre></td></tr></table></figure>
<p>将你需要创建的资源描述到YAML文件中。</p>
<p>部署：kubectl apply -f xxx.yaml</p>
<p>卸载：kubectl delete -f xxx.yaml</p>
<p><img src="/images/049922DAA12B45238787D8DCE47434FBclipboard.png" alt></p>
<h2 id="资源字段太多，记不住怎么办">资源字段太多，记不住怎么办</h2>
<p>用create命令生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx:1.16 -o yaml --dry-run=client &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>用get命令导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment nginx -o yaml &gt; my-deploy.yaml</span><br></pre></td></tr></table></figure>
<p>Pod容器的字段拼写忘记了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain pods.spec.containers </span><br><span class="line">kubectl explain deployment</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像的制作CMD与ENTRYPOINT区别</title>
    <url>/2022/05/24/%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%B6%E4%BD%9Ccmd%E4%B8%8Eentrypoint%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.构建镜像时必须指定一个CMD 或者ENTRYPOINT 去夯住进程，不让它退出，放在容器前台执行，否则容器就退出了。</p>
<p>2.CMD exec 形式变量传参需要指定（“sh”,“-c”,“/usr/bin/run.sh $abc”）</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD [“sh”,“-c”,“/usr/bin/run.sh $abc”]</p>
<p>3.CMD shell形式直接使用变量传参</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>CMD <a href="http://run.sh">run.sh</a> $abc</p>
<p>4.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> liuzhe</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的CMD命令</p>
<p>5.docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>docker run -d test <a href="http://run.sh">run.sh</a> wangwu</p>
<p>通过命令行指定的形式覆盖Dockerfile 中的ENTRYPOINT命令需要指定 --entrypoint参数</p>
<p>6.当CMD和ENTRYPOINT配合使用时，CMD的值会作为ENTRYPOINT 的默认参数</p>
<p>FROM centos:7</p>
<p>LABEL maintalner liuzhe</p>
<p>COPY <a href="http://run.sh">run.sh</a> /usr/bin</p>
<p>ENV abc=azhe</p>
<p>EXPOSE 80</p>
<p>ENTRYPOINT [“<a href="http://run.sh">run.sh</a>”]     #ENTRYPOINT执行 可执行文件  必须使用exec的形式</p>
<p>CMD [“hello”,“libai”]      #CMD的值为ENTRYPOINT传参</p>
<p>#####<a href="http://run.sh#######">run.sh#######</a></p>
<p>#!/bin/bash</p>
<p>echo $@</p>
<p>sleep 70000</p>
<p>最终执行的命令就是</p>
<p>/usr/bin/run.sh hello libai</p>
<p>docker run -d test hello liuzhe 也可以通过命令行的形式覆盖CMD命令的值</p>
<p>小结：</p>
<ol>
<li>
<p>CMD和ENTRYPOINT指令都可以用来定义运行容器时所使用的默认命令</p>
</li>
<li>
<p>Dockerfile至少指定一个CMD或ENTRYPOINT</p>
</li>
<li>
<p>CMD可以用作ENTRYPOINT默认参数，或者用作容器的默认命令</p>
</li>
<li>
<p>docker run指定<command>时，将会覆盖CMD的值</p>
</li>
<li>
<p>如果是可执行文件，希望运行时传参，应该使用ENTRYPOINT</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
